[
  {
    "title": "Accessing Raw Data",
    "route": "/forms/accessing-raw-data/",
    "content": "You can access low-level form data using `NgxExtendedPdfViewerService.getFormData()`.\r\n\r\nYou can use this demo to find out the names of the fields in the PDF file.\r\n\r\n**Note**: The API is subject to change.\r\n\r\nAlso note that radiobuttons (and checkboxes which are used as radiobuttons) have a very peculiar representation. This is a low-level API, so it displays all the internal complexity.\r\n\r\n## TypeScript\r\n\r\n```typescript\r\nexport class FormsComponent {\r\n  \r\n  rawFormData: any[] = [];\r\n  \r\n  constructor(private ngxService: NgxExtendedPdfViewerService) {}\r\n  \r\n  async readRawFormDescription(): Promise<void> {\r\n    const raw = await this.ngxService.getFormData(true);\r\n    this.rawFormData = raw.map((annotation: any) => ({\r\n        alternativeText: annotation.fieldAnnotation.alternativeText,\r\n        fieldName: annotation.fieldAnnotation.fieldName,\r\n        fieldType: annotation.fieldAnnotation.fieldType,\r\n        fieldValue: annotation.fieldAnnotation.fieldValue,\r\n        value: annotation.fieldAnnotation.value,\r\n        id: annotation.fieldAnnotation.id,\r\n        maxLen: annotation.fieldAnnotation.maxLen,\r\n        rect: annotation.fieldAnnotation.rect\r\n      }));\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Alternatives",
    "route": "/about/alternatives/",
    "content": "## Which options do you have to display a PDF file in your Angular application?\r\n\r\nThere's a similar article at <a target=\"#\" href=\"https://beyondjava.net/angular-pdf-viewers-2020\">https://beyondjava.net/angular-pdf-viewers-2020</a> and an older text at <a target=\"#\" href=\"https://www.beyondjava.net/ngx-extended-pdf-viewer\">beyondjava.net/ngx-extended-pdf-viewer</a>.\r\n\r\n## TLDR\r\nIn general, I recommend using either my own PDF viewer, ngx-extended-pdf-viewer, or the PDF viewer of Vadym Yatsyuk, <a href=\"https://www.npmjs.com/package/ng2-pdf-viewer\">ng2-pdf-viewer</a>. Vadym's viewer is the tool of choice if you don't need the menu, the sidebar, or anything else beyond displaying the PDF file. ngx-extended-pdf-viewer is the tool of choice if you need the fancy UI, too.\r\n\r\nIf you need to display multiple PDF files simultaneously and if you don't mind using iFrames, I recommend <a target=\"#\" href=\"https://www.npmjs.com/package/ng2-pdfjs-viewer\">ng2-pdfjs-viewer</a>. The library has less features than ngx-extended-pdf-viewer, but its iFrame approach allows it do some tricks that make it unique. Such as opening a PDF file in a new tab or a new window, or - as I've mentioned before - displaying multiple PDF files side-by-side.\r\n\r\nIf you need to modify PDF files, that's the realm of the commercial solutions. I didn't do much market research, so take my hints with a grain of salt. PDFTron looks interesting, as well as the commercial sibling of ej2-angular-pdfviewer.\r\n\r\n## Using the native browser support\r\n\r\nIn a way, it's crazy to use a library to display PDF files in a browser. Every modern browser can show PDF files natively. Just drag and drop a PDF file into the browser, and you'll see a PDF viewer that's every bit as powerful as Adobe's native PDF viewer.\r\n\r\nOnly - well, there are some outdated versions of our good old friend called Internet Explorer out there. Plus, many other browsers don't support PDF files. Sometimes it's not enough to focus on the evergreen browsers. Adding insult to injury, there's no standardized way to embed a PDF file on a web page, and the public API is limited. What you can do is using the `<object>` tag like so:\r\n\r\n```html\r\n<object data=\"https://example.com/test.pdf#page=2\" type=\"application/pdf\" width=\"100%\" height=\"100%\">\r\n  <p>Your browser does not support PDFs. <a href=\"https://example.com/test.pdf\">Download the PDF</a>.</p>\r\n</object>\r\n```\r\n\r\nPhilipp Spiess has an <a target=\"#\" href=\"https://pspdfkit.com/blog/2018/open-pdf-in-your-web-app/\">exhaustive roundup of this approach</a>. Highly recommended. Be warned: Along the way, he's trying to sell you a professional PDF tool which may or may not be useful. I wouldn't know because both BeyondJava.net and pdfviewer.net are very serious about never doing advertising. So I didn't even evaluate it.\r\n\r\n## Enter pdf.js\r\n\r\nEvery other solution (well, as far as I know) is based on <a href=\"https://mozilla.github.io/pdf.js/\">an open-source PDF viewer called pdf.js</a>. It's written in JavaScript, so it's easy to use the library in your own project. It's also the PDF viewer used by Firefox and Google Chrome. In other words: it's battle-proven and rock-solid.\r\n\r\nSeveral tutorials are telling you how easy it is to use pdf.js. For example, the author I've already quoted, Philipp Spiess, <a href=\"https://pspdfkit.com/blog/2018/render-pdfs-in-the-browser-with-pdf-js/\">has written a nice walkthrough</a>.\r\n\r\nThe catch is it's easy as long as you're happy with just displaying the PDF file without any bells and whistles. As soon as you want to add more features - such as scaling, searching, rotating, printing - complexity quickly gets through the roof. Most tutorials solve the problem by embedding Mozilla's web viewer in an iFrame. The good news is that this approach works. Nonetheless, in many projects, that's a no-go. iFrames went out of fashion for a reason.\r\n\r\nWhat we're looking for is a simple but powerful solution.\r\n\r\n## https://www.npmjs.com/package/ng2-pdfjs-viewer\r\n\r\nDid I say nobody's using iFrames in 2020? A developer nicknamed Code Hippie does. As things go, they implemented their PDF viewer almost at the same time as I did. Their approach is very simple: create an Angular component wrapping the PDF viewer in an iFrame. You can send parameters to the PDF viewer using the URL. That's quite a few parameters, so chances are you're happy with this approach.\r\n\r\nThe iFrame approach is simple and robust. If you're not happy with ngx-extended-pdf-viewer, go for the library of Codehippie. You'll lose some options - but most likely you don't need them anyways.\r\n\r\nAs of December 2023, the library uses a rather old version of pdf.js (2.2), but that shouldn't be a problem in most applications.\r\n\r\n## ng2-pdf-viewer: Displaying PDF files in a no-nonsense way\r\n\r\nThis library is the way to go if you just want to render PDF files and nothing else. No toolbar, no thumbnails, just the plain PDF file. <a href=\"https://www.npmjs.com/package/ng2-pdf-viewer\">ng2-pdf-viewer</a> gives you a decent API and is popular enough to feel trustworthy. At the time of writing, it saw more than 150.000 downloads a month. Some time ago, I presented the library in this showcase, but I removed it again because of compatibility problem with current Angular versions. As of December 2023, the library uses a rather old version of pdf.js (2.6), but that shouldn't be a problem in most applications.\r\n\r\n## ng2-image-viewer\r\n\r\n<b>Warning:</b> ng2-image-viewer is no longer maintained. The GitHub project has been archived. Use this library at your own risk. Plus, the README.md file of the repository contains a link to a questionable site. It seems the base library, ImageViewer, has been abandoned, and it's website has been aquired by a betting portal. If you want to use this library, please be very careful. As a measure of caution, I've removed the hyperlinks. Nonetheless, the library still looks promising, so I don't want to remove this section.\r\n\r\nThis nice library is an image viewer at it's heart. The author, Breno Prata, took the ImageViewer library, wrapped in a carousel, and added PDF support to it.\r\n\r\nAs far as I can see, ng2-image-viewer relies on the browser to render the PDF file natively. Don't hope for Internet Explorer support. Plus, the PDF viewer is always shown completely, without options to customize it. Other than that, it's a nice little library if you need to display the PDF file in a carousel.\r\n\r\n## Angular.js 1.x\r\n\r\nAre you still using AngularJS 1.x? Then you should check out <a href=\"https://github.com/legalthings/angular-pdfjs-viewer\">angular-pdfjs-viewer</a> is a fine library. Unfortunately, the authors ceased to maintain it, so use it at your own risk.\r\n\r\n## ngx-extended-pdf-viewer\r\n\r\nHow does ngx-extended-pdf-viewer compare to the other options? Basically, it offers Internet Explorer 11 support, offers a wide range of attributes and even events. You can call a method when a document has been loaded or a page has been rendered. Plus, it offers two-way binding for many attributes, such as the page number and the zoom factor. You can store the user's zoom preference in the database and fetch it again the next morning, when the user starts working with a fresh browser."
  },
  {
    "title": "Annotation",
    "route": "/configuration/layers/annotation/",
    "content": "Interactive forms are part of this layer.\r\n\r\nThis example uses the event listener `(annotationLayerRendered)` to fix a layout error in the document itself. The author has added a copyright box on page ii. By default, the box is too large, so the box is clipped. That looks attractive, too, but this demo reduces the size of the box to make it fit into the box without clipping it. As a side effect, the underlying link to a popular book vendor becomes visible.\r\n\r\n**Caveat**: the `(annotationLayerRendered)` trick does not work in the thumbnail view.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'./assets/pdfs/The Public Domain - Enclosing the Commons of the Mind.pdf'\"\r\n  (annotationLayerRendered)=\"onAnnotationLayerRendered($event)\"\r\n  [zoom]=\"'auto'\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\npublic onAnnotationLayerRendered(event: AnnotationLayerRenderedEvent): void {\r\n  const copyrightHint = event.source.div.querySelector('.freeTextAnnotation');\r\n  if (copyrightHint && copyrightHint instanceof HTMLElement) {\r\n    copyrightHint.style.left=\"20%\";\r\n    const canvas = copyrightHint.querySelector(\"canvas\");\r\n    if (canvas) {\r\n        canvas.style.width=\"75%\";\r\n        canvas.style.height=\"75%\";\r\n        canvas.style.top=\"20px\";\r\n        canvas.style.left=\"10%\";\r\n    }\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Authentication And Authorization",
    "route": "/configuration/authentication-and-authorization/",
    "content": "## Keycloak\r\n\r\nTo display the PDF file, you have to pass the attribute `authorization` like so:\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n        [src]=\"'http://localhost:8080/api/documents/testpdf'\"\r\n        [authorization]=\"bearerToken\"\r\n>\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\nYou must retrieve the bearer token in the TypeScript code. This might look like so:\r\n\r\n```typescript\r\n@Component(...)\r\nexport class NgxExtendedPdfTestComponent implements OnInit {\r\n  public bearerToken: string | undefined = undefined;\r\n\r\n  constructor(private keycloakService: KeycloakService) {}\r\n\r\n  ngOnInit(): void {\r\n    this.bearerToken = 'Bearer ' + this.keycloakService.getToken();\r\n  }\r\n}\r\n```\r\n\r\nNote that you have to add the prefix `\"Bearer \"` yourself. That's necessary because other auth servers don't require the prefix.\r\n\r\n## Example project\r\n\r\n[Marcel Karras](https://github.com/MKITConsulting) kindly provided a demo project: [Link to demo project](https://github.com/stephanrauh/ngx-extended-pdf-viewer-issues/tree/main/oauth2-ngx-extended-pdf-viewer-test).\r\n\r\nTo run it, just follow the instructions of the readme file.\r\n\r\n## Other auth providers\r\n\r\nHMAC *should* work similarly, but it doesn't require the prefix `\"Bearer \"`. Just pass the access token to `authorization`.\r\n\r\nIf you need more flexibility, you can\r\n\r\n- use the attribute `httpHeaders` to pass an arbitrary array of http headers\r\n- set `[authorization]=\"true\"`. In this case, the authorization header is not set. However, the flag `withCredentials` of the XMLHttpRequest is set to true. If pdf.js uses the modern fetch API instead, `withCredentials` activates the option `credentials: 'include'`\r\n\r\n### Links for more details\r\n\r\n- [Documentation on XMLHttpRequests with credentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials)\r\n- [Documentation on Fetch API - sending a request with credentials](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#sending_a_request_with_credentials_included)"
  },
  {
    "title": "Base64",
    "route": "/basics/file-sources/base64/",
    "content": "The `base64Src` attribute allows you to specify a document, that was encoded as a base64 string. This can be useful, for cases where you get a file via an API call.\r\n\r\n**Caveat**: I've seen developers populating both `[src]` and `[base64src]`. Please avoid doing so. There's no way to predict which of the two attributes is actually used.\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n    [base64Src]=\"base64\"\r\n    [height]=\"'90vh'\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### Typescript\r\n```ts\r\n@Component({ ... })\r\nexport class FileSourcesComponent {\r\n  public base64 = new Subject<string>();\r\n\r\n  constructor(private httpClient: HttpClient) {}\r\n\r\n  public ngOnInit(): void {\r\n    this.httpClient.get<string>(\r\n      '/assets/pdfs/Bootstrap-vs-Material-Design-vs-Prime-vs-Tailwind.base64.txt',\r\n      { responseType: 'text' as 'json' })\r\n      .pipe(\r\n        tap((base64) => this.base64 = base64),\r\n      ).subscribe();\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Blob",
    "route": "/exporting/blob/",
    "content": "You can export the PDF as a Blob, including filled fields and drawings, texts, images, and highlights added by the user.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n    [src]=\"'/assets/pdfs/blind-text-collection.pdf'\"\r\n    [textLayer]=\"true\" <!-- enable the find button -->\r\n    [showHandToolButton]=\"true\" <!-- enable text selection -->\r\n    [height]=\"'90vh'\"> <!-- by default, most CSS frameworks set the height to 0 -->\r\n</ngx-extended-pdf-viewer>\r\n```\r\n## TypeScript\r\n\r\n```typescript\r\nconstructor(private pdfViewerService: NgxExtendedPdfViewerService) {}\r\n\r\n  public blob: Blob | undefined;\r\n  \r\n  public async export(): Promise<void> {\r\n    this.selectedTabIndex = 2;\r\n    this.blob = await this.pdfViewerService.getCurrentDocumentAsBlob();\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Blobs",
    "route": "/basics/file-sources/blobs/",
    "content": "To display a BLOB, just pass it to the src attribute.\r\n\r\nYou can also download the PDF file as a BLOB. For instance, the user can upload a file, and you can use the method `NgxExtendedPdfViewerService.getCurrentDocumentAsBlob()` to send the file to your server. Or the user can fill a form embedded in the PDF file, and you can download the file containing the user's input.\r\n\r\n### Html\r\n\r\n```html\r\n<ngx-extended-pdf-viewer \r\n    [(src)]=\"src\"\r\n    [height]=\"'90vh'\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### Typescript\r\n```ts\r\n@Component({ ... })\r\nexport class FileSourcesComponent {\r\n  public src: Blob;\r\n\r\n  constructor(private http: HttpClient, private blobService: BlobService, private ngxService: NgxExtendedPdfViewerService) {\r\n    this.usePreloadedFile();\r\n  }\r\n\r\n  public usePreloadedFile(): void {\r\n    this.src = this.blobService.src;\r\n  }\r\n\r\n  public loadLargeFile(): void {\r\n    this.http\r\n      .get(\r\n        '/assets/pdfs/The Public Domain - Enclosing the Commons of the Mind.pdf',\r\n        { responseType: 'blob' }\r\n      )\r\n      .subscribe((res) => this.src = res);\r\n  }\r\n\r\n  public async downloadAsBlob(): Promise<void> {\r\n    const blob = await this.ngxService.getCurrentDocumentAsBlob();\r\n    // Handle download or additional logic\r\n  }\r\n}\r\n```\r\n\r\n### Troubleshooting\r\n\r\nIn rare cases, developers report they can't open the BLOB, but managed to open the same file as a Base64 file using the attribute `[base64src]`. You can use this code snippets to convert a BLOB to a Base64 file:\r\n\r\n```ts\r\nfunction blobToBase64(blob): Promise<string> {\r\n  return new Promise((resolve, reject) => {\r\n    const reader = new FileReader();\r\n    reader.onload = () => {\r\n        const dataUrl = reader.result as string;\r\n        const base64 = dataUrl.split(',')[1];\r\n        resolve(base64);\r\n    };\r\n    reader.readAsDataURL(blob);\r\n  });\r\n}\r\n```"
  },
  {
    "title": "Browser Support",
    "route": "/about/browser-support/",
    "content": "The goal of the project is to be compatible with almost every popular browser that's up-to-date. In other words, I frequently run tests on Chrome, Firefox, and Safari on an iPad, and I update all of them pretty soon.\r\n\r\nThere's also a limited support for older browsers:\r\n\r\n- By default, the library ships binaries compiled to a pretty contemporary JavaScript version. The precise EcmaScript version varies over time,\r\n  but sometimes even the ESR versions of Firefox are too old to run this code.\r\n- As a fallback, the library can also run ES2015 code. Most of the time, this suffices to run the PDF viewer on iOS and Android devices\r\n  that haven't been updated during the last one or two years.\r\n- Internet Explorer is not supported. If you need an IE11 version, you can try ngx-extended-pdf-viewer 7.3.2,\r\n  but without any support from my side.\r\n\r\nWhen the library initializes, it runs a few checks:\r\n\r\n- Does the browser support private fields and methods using the `#` prefix?\r\n- Does it support optional chaining?\r\n- Does ot support logical assignment operators?\r\n\r\nIf any of these checks fails, the library uses the slow and huge ES2015 build.\r\n\r\nIn case of an emergency, you can force ngx-extended-pdf-viewer to use the ES2015 build by setting the attribute `[forceUsingLegacyES5]=\"true\"`."
  },
  {
    "title": "Buttons",
    "route": "/customization/buttons/",
    "content": "You can hide every button of the toolbar and every menu item of the secondary menu.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/pdf-sample.pdf'\"\r\n  [showToolbar]=\"true\"\r\n  [showSidebarButton]=\"false\"\r\n  [showFindButton]=\"true\"\r\n  [showPagingButtons]=\"false\"\r\n  [showDrawEditor]=\"false\"\r\n  [showStampEditor]=\"false\"\r\n  [showTextEditor]=\"false\"\r\n  [showZoomButtons]=\"false\"\r\n  [showPresentationModeButton]=\"false\"\r\n  [showOpenFileButton]=\"false\"\r\n  [showPrintButton]=\"false\"\r\n  [showDownloadButton]=\"true\"\r\n  [showSecondaryToolbarButton]=\"true\"\r\n  [showRotateButton]=\"undefined\"\r\n  [showRotateCwButton]=\"false\"\r\n  [showRotateCcwButton]=\"false\"\r\n  [showHandToolButton]=\"false\"\r\n  [showScrollingButtons]=\"false\"\r\n  [showSpreadButton]=\"false\"\r\n  [showPropertiesButton]=\"false\">\r\n</ngx-extended-pdf-viewer>\r\n```"
  },
  {
    "title": "Checkboxes And Radiobuttons",
    "route": "/forms/checkboxes-and-radiobuttons/",
    "content": "Checkboxes and radiobuttons are remarkable flexible in PDF forms:\r\n\r\nCheckboxes usually don't map to boolean values. Instead, they often use \"export values\" like \"Yes\" and \"No\".\r\nCheckboxes can be used as radiobuttons and vice versa.\r\nngx-extended-pdf-viewer aims to support all these options. However, even after so many years of development users report bugs because my original implementation was too simple. I hope I've managed to fix all the bugs now.\r\n\r\nOne result of my original misconception is that checkboxes both support boolean values and the real export values. However, the `(formData)` event always reports the export values. You need to convert it to boolean values yourself.\r\n\r\nYou can find the source code at https://github.com/stephanrauh/extended-pdf-viewer-showcase/tree/main/src/app/extended-pdf-viewer/forms."
  },
  {
    "title": "Content Security Policy",
    "route": "/developer-experience/content-security-policy/",
    "content": "The PDF viewer supports Content Security Policy (CSP) by default. However, if you don't need CSP, the PDF viewer can load the PDF file faster if you disable it. To be honest, at the moment the difference is only a single request, but if the idea carries fruit, maybe there's more to come.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n    [src]=\"'./assets/pdfs/2404.00465v1.pdf'\"\r\n    [useInlineScripts]=\"false\">\r\n</ngx-extended-pdf-viewer>\r\n```"
  },
  {
    "title": "Context Menu",
    "route": "/configuration/context-menu/",
    "content": "The context menu of the pdf viewer adds little value. In some cases, it may even confuse users. So you can use the attribute `[contextMenuAllowed]=\"false\"` to get rid of built-in browser options like \"Save As Image\" and \"Inspect\"."
  },
  {
    "title": "Contributors",
    "route": "/contributing/contributors/",
    "content": "# Contributors\r\n\r\n**Thanks to all the contributors!**"
  },
  {
    "title": "Custom Find Algorithm",
    "route": "/finding/custom-find-algorithm/",
    "content": "This is a very advanced usecase.\r\n\r\n## Since Version 21.3.0\r\n\r\nIf you want to implement your own find algorithm, define a class implementing the find controller and pass it to the attribute `pdfDefaultOptions.findController` _before_ opening the PDF file.\r\n\r\nTo get started, copy the files `pdf_find_controller.js`, `ui_utils.js`, and `pdf_find_utils.js` from the source code of this showcase to your project and extend your own find controller from the class `PDFFindController`.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  src=\"/assets/pdfs/Portugues-para-principiantes-1538054164.pdf\"\r\n  [textLayer]=\"true\"\r\n  [showFindButton]=\"false\"\r\n  (updateFindMatchesCount)=\"onUpdateFindMatchesCount($event)\"\r\n  (pdfLoaded)=\"pdfLoaded()\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n#### Component\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false, ...})\r\nexport class CustomFindComponent {\r\n\r\n  constructor() {\r\n    pdfDefaultOptions.findController = MyCustomFindController;\r\n  }\r\n}\r\n```\r\n\r\n#### Custom Find Controller Class\r\n\r\n````typescript\r\nimport { PDFFindController } from './pdf_find_controller';\r\n\r\nexport class MyCustomFindController extends PDFFindController {\r\n  constructor({ linkService, eventBus, updateMatchesCountOnProgress = true, pageViewMode }: any) {\r\n    super({ linkService, eventBus, updateMatchesCountOnProgress, pageViewMode });\r\n    console.log('MyFindController constructor');\r\n  }\r\n}\r\n````\r\n\r\n## Before Version 21.3.0\r\n\r\nDemonstration of customizing the find functionality. This works by overriding the default find functionality of the pdf.js viewer, adding support for regex search in this example. A more complete implementation would provide a custom find bar.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  src=\"/assets/pdfs/Portugues-para-principiantes-1538054164.pdf\"\r\n  [textLayer]=\"true\"\r\n  [showFindButton]=\"false\"\r\n  (updateFindMatchesCount)=\"onUpdateFindMatchesCount($event)\"\r\n  (pdfLoaded)=\"pdfLoaded()\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\ninterface CustomFindOptions extends FindOptions {\r\n  matchRegex: boolean;\r\n}\r\n\r\n@Component({\r\nstandalone: false, ...})\r\nexport class CustomFindComponent {\r\n  searchtext = '(?<=\\\\s)([A-z]+ough)';\r\n  findOptions: CustomFindOptions = {\r\n    highlightAll: true,\r\n    matchCase: false,\r\n    wholeWords: false,\r\n    matchDiacritics: false,\r\n    matchRegex: true\r\n  };\r\n\r\n\r\n  constructor(notificationService: PDFNotificationService) {\r\n    effect(() => this.pdfViewerApplication = notificationService.onPDFJSInitSignal());\r\n  }\r\n\r\n  // Override the find feature to support regex after the PDF is loaded\r\n  pdfLoaded() {\r\n    this.overrideFindFeature();\r\n  }\r\n\r\n  // Optional: Restore the original find feature\r\n  ngOnDestroy() {\r\n    this.restoreFindFeature();\r\n  }\r\n\r\n  findRegex() {\r\n    this.dispatchFind('find');\r\n  }\r\n\r\n  findNext(): void {\r\n    this.dispatchFind('again', false);\r\n  }\r\n\r\n  findPrevious(): void {\r\n    this.dispatchFind('again', true);\r\n  }\r\n\r\n  /**\r\n   * Override the find feature to support regex\r\n   */\r\n  private overrideFindFeature() {\r\n    const findController = this.pdfViewerApplication.findController as any;\r\n\r\n    const originalConvertToRegExpString = findController._convertToRegExpString;\r\n    findController._convertToRegExpString = (query: string, ...args: any[]) => {\r\n      const { matchRegex } = findController.state;\r\n\r\n      // If not matchRegex, call the original method\r\n      if (!matchRegex) return originalConvertToRegExpString.call(findController, query, ...args);\r\n\r\n      // If matchRegex, return the query as is\r\n      return [false, query];\r\n    };\r\n  }\r\n\r\n  // Need to use dispatch directly\r\n  private dispatchFind(type: string, findPrevious = false): void {\r\n    this.pdfViewerApplication.eventBus.dispatch('find', {\r\n      ...this.findOptions,\r\n      query: this.searchtext,\r\n      type,\r\n      findPrevious,\r\n      source: undefined\r\n    });\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Custom Print Progress",
    "route": "/printing/custom-print-progress/",
    "content": "Using the `progress` event of the `ngx-extended-pdf-viewer` allows you to display your own progress or other ways of user feedback.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/A%20COOL%20KID%20LIKE%20ME.pdf'\"\r\n  zoom=\"50%\"\r\n  [showToolbar]=\"false\"\r\n  (beforePrint)=\"onBeforePrint()\"\r\n  (afterPrint)=\"onAfterPrint()\"\r\n  (progress)=\"onProgress($event)\">\r\n</ngx-extended-pdf-viewer>\r\n@if (showProgress) {\r\n<div style=\"padding-bottom:10px; padding-top:10px\">\r\n  <div>Processing page {{ currentPageRendered }} of {{ totalPages }}</div>\r\n</div>\r\n}\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,...})\r\nexport class CustomPrintDialogComponent {\r\n  public printPercentage = 0;\r\n  public totalPages = 0;\r\n  public currentPageRendered = 0;\r\n  public showProgress = false;\r\n  public hideBuiltInProgress = true;\r\n\r\n  constructor(private pdfService: NgxExtendedPdfViewerService) {  }\r\n\r\n  public onBeforePrint() {\r\n    if (this.hideBuiltInProgress) {\r\n      const node = document.querySelector('.pdf-wrapper #printServiceDialog') as Element;\r\n      node.setAttribute('style', 'display:none!important');\r\n    }\r\n    this.showProgress = true;\r\n  }\r\n\r\n  public onAfterPrint() {\r\n    const node = document.querySelector('.pdf-wrapper #printServiceDialog') as Element;\r\n    node.removeAttribute('style');\r\n    this.showProgress = false;\r\n  }\r\n\r\n  public onProgress(event: ProgressBarEvent): void {\r\n    if (this.showProgress) {\r\n      this.totalPages = event.total;\r\n      this.printPercentage = event.percent;\r\n      this.currentPageRendered = event.page ?? 0;\r\n    }\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Default Options",
    "route": "/basics/default-options/",
    "content": "## Overriding Options\r\n\r\nYou can fine-tune the behavior of the PDF viewer by modifying the default options. Most options are very advanced or covered by regular attributes of `<ngx-extended-pdf-viewer />`, so use the options at your own risk.\r\n\r\n### TypeScript\r\n\r\n```typescript\r\nimport { pdfDefaultOptions } from 'ngx-extended-pdf-viewer';\r\n\r\n@Component({ ... })\r\nexport class DefaultOptionsComponent {\r\n  constructor() {\r\n    pdfDefaultOptions.assetsFolder = 'bleeding-edge';\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Default Values",
    "route": "/forms/default-values/",
    "content": "It can happen that the PDF form shows a different value than what was set through your application. That's because the PDF form has its own default value.\r\n\r\nThe Angular application passes a different default value using `[formData]`. But because the value gets passed _before_ the page has loaded, the default value of the PDF form takes precedence.\r\n\r\nTo ensure that the value coming from your code is used instead, you have to delay populating `[formData]` until the page has been rendered. Which approach you should use highly depends on what you do with the viewer and the form data.\r\n\r\nHere are some ideas:\r\n- Use `ngAfterViewInit`\r\n- Use `pageRendered` event of the `ngx-extended-pdf-viewer`"
  },
  {
    "title": "Display Options",
    "route": "/viewing/display-options/",
    "content": "A few options allow you to influence the way the PDF file is rendered. You can explore those options in the demo.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n    [src]=\"'/assets/pdfs/codpaste-teachingpack.pdf'\"\r\n    [showBorders]=\"showBorders\"\r\n    [(scrollMode)]=\"scrollMode\"\r\n    [(pageViewMode)]=\"pageViewMode\"\r\n    [(spread)]=\"spread\"\r\n    zoom=\"30%\"\r\n    [showVerticalScrollButton]=\"'always-visible'\"\r\n    [showHorizontalScrollButton]=\"'always-visible'\"\r\n    [showWrappedScrollButton]=\"'always-visible'\"\r\n    [showSpreadButton]=\"'always-visible'\"\r\n    [showInfiniteScrollButton]=\"'always-visible'\"\r\n    [showBookModeButton]=\"'always-visible'\"\r\n    [showSinglePageModeButton]=\"'always-visible'\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({ ... })\r\nexport class DisplayOptionsComponent {\r\n  public showBorders = false;\r\n\r\n  public scrollMode = ScrollModeType.horizontal;\r\n\r\n  public pageViewMode: PageViewModeType = 'multiple';\r\n\r\n  public spread: 'off' | 'odd' | 'even' = 'off';\r\n}\r\n```\r\n\r\n## Single Page Mode \r\n\r\nThe PDF viewer supports the single-page mode. In this mode, you can scroll from page to page. Instead, you can only navigate to a new page by setting the page number or clicking a chapter in the sidebar.\r\n\r\n## Book\r\n\r\nThe book mode displays the PDF file like a book and renders a nice page-turn effect.\r\n\r\nBook mode suffers from a couple of limitations:\r\n\r\n- You can't zoom\r\n- Presentation mode doesn't work\r\n- If the available space of the viewer isn't wide enough, weird effects happen\r\n\r\n## Infinite Scroll\r\n\r\nThis option allows you to display the PDF file without scrollbar."
  },
  {
    "title": "Displaying Forms",
    "route": "/forms/displaying-forms/",
    "content": "If you're using the default options, you don't have to do anything to activate the feature. If you're using custom options, make sure to activate the setting `renderInteractiveForms: true`. \r\n\r\n**Note**: Starting with pdf.js 2.11, the parameter has been renamed to renderForms.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/OoPdfFormExample.pdf'\"\r\n  [height]=\"'90vh'\"\r\n  [(formData)]=\"formData\"\r\n>\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n### Using single properties\r\n\r\n```typescript\r\nexport class FormsComponent {\r\n  firstName = 'Jane';\r\n  lastName = 'Doe';\r\n  country = 'Spain';\r\n  jobExperience = '6';\r\n  typeScript = true;\r\n\r\n  public get formData(): FormDataType {\r\n    return {\r\n      firstName: this.firstName,\r\n      lastName: this.lastName,\r\n      yearsOfExperience: this.jobExperience,\r\n      typeScript: this.typeScript,\r\n      country: this.country\r\n    };\r\n  }\r\n\r\n  public set formData(data: FormDataType) {\r\n    this.firstName = data.firstName as string;\r\n    this.lastName = data.lastName as string;\r\n    this.jobExperience = data.yearsOfExperience as string;\r\n    this.country = data.country as string;\r\n    this.typeScript = data.typeScript === 'true' || data.typeScript === true;\r\n  }\r\n}\r\n```\r\n\r\n### Using object\r\n\r\n**Note**: If you are using checkboxes in your form, that do **not** map into a boolean value, it is better to use the getter/setter pattern. You can find more details under the [Checkboxes and Radiobuttons Page](./forms/checkboxes-and-radiobuttons)\r\n\r\n```typescript\r\nexport class FormsComponent {\r\n\r\n  formData: FormDataType = {\r\n    firstName: 'Jane',\r\n    lastName: 'Doe',\r\n    country: 'Spain',\r\n    jobExperience: '6',\r\n    typeScript: true,\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Downloading",
    "route": "/forms/downloading/",
    "content": "You can download the PDF file as a BLOB. The user can fill the PDF form, and you can download the file containing the user's input.\r\n\r\n## TypeScript\r\n\r\n```typescript\r\nexport class FormsComponent {\r\n  public downloaded: string | undefined;\r\n\r\n  constructor(private ngxService: NgxExtendedPdfViewerService) {}\r\n\r\n  public async downloadAsBlob(): Promise<void> {\r\n    const blob = await this.ngxService.getCurrentDocumentAsBlob();\r\n    if (blob) {\r\n      this.downloaded = 'The BLOB contains ' + blob.size + ' byte.';\r\n    } else {\r\n      this.downloaded = 'download failed';\r\n    }\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Editor Api",
    "route": "/developer-experience/editor-api/",
    "content": "ngx-extended-pdf-viewer provides access to some additional apis-\r\n\r\n## Settings\r\n\r\nYou can set some of the properties of the editors. The example below sets all possible values in the constructor of the component. Of course, you can get those values from the user or some other place too. The comments show what kind of value is valid for the property.\r\n\r\n### TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class EditorApiComponent {\r\n  \r\n  constructor(private pdfViewerService: NgxExtendedPdfViewerService) {\r\n    \r\n    // Number between 1 and 100\r\n    this.pdfViewerService.editorFontSize = 12;\r\n    \r\n    // Hex Color\r\n    this.pdfViewerService.editorFontColor = '#000000';\r\n\r\n    // Hex Color\r\n    this.pdfViewerService.editorInkColor = '#000000';\r\n    \r\n    // Number between 0 and 100\r\n    this.pdfViewerService.editorInkOpacity = 80;\r\n    \r\n    // Number between 1 and 20 \r\n    this.pdfViewerService.editorInkThickness = 10;\r\n\r\n    // Hex Color\r\n    this.pdfViewerService.editorHighlightColor = '#de3535';\r\n\r\n    // Hex Color\r\n    this.pdfViewerService.editorHighlightDefaultColor = '#de3535';\r\n    \r\n    // Boolean\r\n    this.pdfViewerService.editorHighlightShowAll = true;\r\n    \r\n    // Number between 1 and 24\r\n    this.pdfViewerService.editorHighlightThickness = 10;\r\n  }\r\n}\r\n```\r\n\r\n## High Level API\r\n\r\n### Adding Images\r\n\r\nAdding images to a PDF file is a popular feature. While this is not possible with this library - it is a viewer, not an editor - you can do something similar. You add an an image to the annotation layer. In most cases, you won't see the difference.\r\n\r\n#### TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class EditorApiComponent {\r\n\r\n  constructor(private pdfService: NgxExtendedPdfViewerService) {}\r\n\r\n  public async addImage(): Promise<void> {\r\n    const { left, bottom, right, top, rotation } = parameters;\r\n    await this.pdfService.addImageToAnnotationLayer({\r\n      urlOrDataUrl: 'assets/images/ChatGPT-PDF-Viewer-Logo.jpg',\r\n      page: 11,       // optional parameter\r\n      left: 0,        // default value: 0\r\n      bottom: '0%',   // default value: 0\r\n      right: '100%',  // default value: 100%\r\n      top: '100%',    // default value: 100%\r\n      rotation: 270   // default value: 0\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n#### Coordinates\r\n\r\nThe parameters `left`, `bottom`, `right`, and `top` can be:\r\n\r\n- percentages (e.g. `left: '50%'`)\r\n- pixels (e.g. `left: '100px'`)\r\n- PDF coordinates (e.g. `left: 100`)\r\n\r\nIf you omit a coordinate, it's put at the logical origin:\r\n\r\n- omitting left amounts to left: 0\r\n- omitting bottom amounts to bottom: 0\r\n- omitting right amounts to right: \"100%\"\r\n- omitting top amounts to top: \"100%\"\r\n\r\n**Caveat**: In Chrome, the calculation of the bottom coordinate appears to be off by a few pixels. This discrepancy seems to stem from a bug in the PDF rendering engine, resulting in a canvas that is larger than expected (at least in my demo documents). This issue does not occur in Firefox.\r\n\r\n\r\n### Large Files\r\n\r\nThe PDF viewer renders pages lazily. If they aren't going to be used soon, the page is not rendered. If you've got a large file, a major part of the pages are just placeholders.\r\n\r\nThis, in turn, means you can't add an annotation. If you want to add annotations to large files reliably, catch the event `(annotationLayerRendered)` and add the annotations in the event handler. Note that this event is triggered for every page individually. The event handler should add the annotations that belong to this particular page, but not to other pages.\r\n\r\n\r\n## Low Level\r\n\r\n### Adding and exporting text, drawing, images and highlights\r\n\r\nYou can add texts and drawings programmatically. However, the PDF viewer doesn't support adding highlights programmatically. As for images, that's supported, but using the high-level API (see [Adding Images](#adding-images)).\r\n\r\n**Breaking change between pdf.js 3.5 and 3.9**: The coordinates of the serialized drawings have changed. Please keep in mind that this is an internal API of pdf.js, so it's subject to change without notice.\r\n\r\nYou can export text, drawings, images, and highlight you've added to a PDF file. For more details on exporting text and images refer to the Exporting Section.\r\n\r\n- [Export Text](./exporting/text)\r\n- [Export Image](./exporting/image)\r\n\r\n\r\n#### TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class EditorApiComponent {\r\n\r\n  constructor(private pdfService: NgxExtendedPdfViewerService) {}\r\n\r\n  public addTextEditor(): void {\r\n    const textEditorAnnotation: FreeTextEditorAnnotation = {\r\n      annotationType: 3,\r\n      color: [Math.floor(Math.random() * 255), Math.floor(Math.random() * 255), Math.floor(Math.random() * 255)],\r\n      fontSize: Math.random() * 10 + 20,\r\n      value: 'Hello world!',\r\n      pageIndex: 0,\r\n      rect: [\r\n        50, // height?\r\n        Math.random() * 500 + 350, // y\r\n        Math.random() * 400, // x\r\n        100, // width?\r\n      ],\r\n      rotation: 0,\r\n    };\r\n    this.pdfService.addEditorAnnotation(textEditorAnnotation);\r\n  }\r\n\r\n  public async addDrawing(): Promise<void> {\r\n    const x = 400*Math.random();\r\n    const y = 350+500*Math.random();\r\n    const drawing: InkEditorAnnotation = {\r\n      annotationType: 15,\r\n      color: [Math.floor(Math.random() * 255), Math.floor(Math.random() * 255), Math.floor(Math.random() * 255)],\r\n      thickness: Math.random()*10,\r\n      opacity: 1,\r\n      paths: [\r\n        {\r\n          bezier: [x+0.5, y, x+0.5, y+44, x+44, y+66, x+88, y+44],\r\n          points: [x+0.5, y, x+0.5, y+44],\r\n        },\r\n      ],\r\n      pageIndex: 0,\r\n      rect: [x, y, x+100, y+66],\r\n      rotation: 0,\r\n    };\r\n    await this.pdfService.addEditorAnnotation(drawing);\r\n  }\r\n\r\n  public exportAnnotations(): void {\r\n    this.selectedTabIndex = 4;\r\n    this.rawAnnotations = this.pdfService.getSerializedAnnotations();\r\n  }\r\n}\r\n```\r\n\r\n### Removing Editor\r\n\r\nBoth forms and editor annotations are PDF annotation, so it might happen the APIs get in the way of each other. Until version 19.6.6, removing an editor would also remove the form fields. This has been fixed in version 19.6.7.\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class EditorApiComponent {\r\n\r\n  constructor(private pdfService: NgxExtendedPdfViewerService) {}\r\n\r\n  public removeEditors(): void {\r\n    this.pdfService.removeEditorAnnotations();\r\n  }\r\n\r\n  public removeTextEditors(): void {\r\n    const filter = (serial: any) =>\r\n      serial?.annotationType === 3 &&\r\n      serial?.pageIndex === 0;\r\n    this.pdfService.removeEditorAnnotations(filter);\r\n  }\r\n\r\n  public removeDrawingEditors(): void {\r\n    const filter = (serial: any) => serial.annotationType === 15;\r\n    this.pdfService.removeEditorAnnotations(filter);\r\n  }\r\n}\r\n```"
  },
  {
    "title": "File Sources",
    "route": "/basics/file-sources/",
    "content": "## Tips\r\n\r\nWhen loading a document from an API as a BLOB, Base64 String or a UInt8Array, consider using a resolver. This allows you to do the API call before actually showing the viewer.\r\n\r\nCheckout the [Angular Documentation on ResolveFn](https://angular.dev/api/router/ResolveFn?tab=api) to learn more about how to set this up."
  },
  {
    "title": "Filtering Console.log",
    "route": "/developer-experience/filtering-console.log/",
    "content": "You can override the default function `globalThis.ngxConsoleFilter(logLevel, message)` to filter the log messages.\r\n\r\nThe example below re-defines `ngxConsolefilter()` to grab the version number from the console messages and to store it in a variable so it can be shown here:\r\n\r\n```text\r\nPDF.js: 4.7.700 [7031e2aff] modified by ngx-extended-pdf-viewer 22.0.0\r\n```\r\n\r\nThe original use-case of `ngxConsolefilter()` is suppressing messages you don't want to log. For example, many PDF documents cause the viewer to emit messages like `Warning: TT: undefined function: 32`. That's one of the messages you can almost always safely ignore, so it doesn't make sense to pump it into, say, an ELK stack or Splunk. If your custom implementation of `ngxConsolefilter()` returns `false` depending on the message text, the message is never logged.\r\n\r\n**Breaking change**: Before version 17, you have to register the filter function with theWindow object instead of globalThis.\r\n\r\n## TypeScript\r\n\r\n````typescript\r\n@Component({\r\nstandalone: false, \r\n  selector: 'app-filtering-console-log',\r\n  templateUrl: './filtering-console-log.component.html',\r\n  styleUrls: ['./filtering-console-log.component.css'],\r\n})\r\nexport class FilteringConsoleLogComponent {\r\n  version = '';\r\n\r\n  constructor() {\r\n    globalThis['ngxConsoleFilter'] = (level: string, message: any): boolean => {\r\n      if (message.includes('running on')) {\r\n        this.version = message;\r\n        return false;\r\n      }\r\n      return true;\r\n    }\r\n  }\r\n}\r\n````"
  },
  {
    "title": "Find Programmatically",
    "route": "/finding/find-programmatically/",
    "content": "`ngx-extended-pdf-viewer` provides two APIs to programmatically find something.\r\n\r\n**User Find Controller**\r\n\r\nThe first one is the user find controller, which is part of the UI. This one is reflected in the UI.\r\n\r\n**API Find Controller**\r\n\r\nThe second one is the API find controller, also known as secondary find controller. The API find controller can be used by programmers, and it has the advantage that the user still can use the find functionality without interfering with the API find controller.\r\n\r\nBoth controllers are used via the `NgxExtendedPdfViewerService`. You can inject this service normally.\r\n\r\n## Basic usage\r\n\r\nThe difference in code is very minimal. Besides setting a parameter there isn't any difference.\r\n\r\n### TS \r\n\r\n#### Find via User Find Controller\r\n\r\n```typescript\r\nconst searchText = 'some search text';\r\nthis.ngxExtendedPdfViewerService.find(searchtext, {\r\n  useSecondaryFindcontroller: false\r\n});\r\n```\r\n\r\n#### Find via API Find Controller\r\n\r\n```typescript\r\nconst searchText = 'some search text';\r\nthis.ngxExtendedPdfViewerService.find(searchtext, {\r\n  useSecondaryFindcontroller: true // <- Set this to true\r\n});\r\n```\r\n\r\n### With all find options\r\n\r\n```typescript\r\ninterface FindOptions {\r\n  highlightAll?: boolean;\r\n  matchCase?: boolean;\r\n  wholeWords?: boolean;\r\n  matchDiacritics?: boolean;\r\n  dontScrollIntoView?: boolean;\r\n  findMultiple?: boolean;\r\n  regexp?: boolean;\r\n  useSecondaryFindcontroller?: boolean;\r\n}\r\n\r\n\r\nconst searchText = 'some search text';\r\nthis.ngxExtendedPdfViewerService.find(searchtext, {\r\n  highlightAll: this.highlightAll,\r\n  matchCase: this.matchCase,\r\n  wholeWords: this.wholeWord,\r\n  matchDiacritics: this.matchDiacritics,\r\n  findMultiple: this.multiple,\r\n  regexp: this.matchRegExp,\r\n  dontScrollIntoView: this.dontScrollIntoView,\r\n  useSecondaryFindcontroller: false\r\n});\r\n```\r\n\r\n## Find Results\r\n\r\nThe event `(updateFindMatchesCount)` contains three attributes telling you about the search result:\r\n\r\n- `matches` is an array of arrays of numbers. The first dimension is the page index. If there's a find result on a page, the inner array is a list of find positions. Basically, such a position the number of characters before the hit.\r\n- `matchesLength` is a similar array of arrays of numbers. In a nutshell, it tells you how long your search term is.\r\n\r\nYou can get the text of each page by calling `ngxPdfViewerService.getPageAsText()`. If you want to find out which part of the DOM shows the find result, you need to catch the event `renderedtextlayerhighlights`.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  src=\"/assets/pdfs/Portugues-para-principiantes.pdf\"\r\n  (updateFindMatchesCount)=\"updateFindMatchesCount($event)\"\r\n  (updateFindState)=\"updateFindState($event)\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\nupdateFindMatchesCount(result: FindResultMatchesCount) {\r\n  // ... your logic\r\n}\r\n\r\nupdateFindState(result: FindState) {\r\n  // ... your logic\r\n}\r\n```\r\n\r\nThis example shows how to access the `renderedtextlayerhighlights` event.\r\n\r\n```typescript\r\nthis.PDFViewerApplication?.eventBus?.on('renderedtextlayerhighlights', (event: RenderedTextLayerHighlights) => {\r\n  event.highlights.forEach((highlight) => {\r\n    highlight.style.border = '2px solid black';\r\n  });\r\n});\r\n```"
  },
  {
    "title": "General",
    "route": "/security/general/",
    "content": "Let's face it: humans are fallible. I'm no exception. So there's no way to guarantee this library is free of security holes. If you find one, please report it to me. I'll fix it as soon as possible.\r\n\r\nThat said, security is a top-priority issue for me. I'm using Dependabot, Snyk, and Mend Bolt to keep the dependencies up-to-date and to notify me about security issues. The result is a flood of false positives, but at least I know the issues and can decide whether they are relevant.\r\n\r\nngx-extended-pdf-viewer uses a fork of pdf.js, which is the core of this project. pdf.js is a very mature library, it's the PDF viewer of Firefox, and many other projects use it. Generally speaking, the quality of pdf.js is remarkable. But of course, even pdf.js is maintained by fallible humans, and it's been subject to security issues in the past.\r\n\r\nI suppose by now you know why ngx-extended-pdf-viewer doesn't ship with any warranty, so I recommend checking public vulnerability reports for pdf.js and ngx-extended-pdf-viewer every once in a while. For example, www.cvedetails.com or [Snyk (pdf.js)](https://security.snyk.io/package/npm/pdfjs-dist), [Snyk (ngx-extended-pdf-viewer)](https://security.snyk.io/package/npm/ngx-extended-pdf-viewer), or [Wordfence](https://www.wordfence.com/threat-intel/vulnerabilities/wordpress-plugins/pdfjs-viewer-shortcode/) are good starting points.\r\n\r\n[Sonarcloud](https://sonarcloud.io/summary/new_code?id=stephanrauh_ngx-extended-pdf-viewer) monitors ngx-extended-pdf-viewer. The idea is that I check the results and heed them. As things go, I often forget to do so. Feel free to nudge me if I'm lazy again!\r\n\r\nWith very few exceptions, I never maintain old versions of ngx-extended-pdf-viewer. Every improvement goes into the main branch and nowhere else. So if you're using an old version, you're missing out on bug fixes and security improvements. I've aware that this is inconvenient or even annoying. It's what happens when you're maintaining a project alone in your spare time. I'd love to offer stuff like long-term support, and that's where you come into play. Can I talk you into contributing to this project?\r\n\r\nWrapping it up, I'm trying to address security as best as possible, but this library ships without warranties. You're using it at your own risk. Please update the latest version as soon as possible, and report security issues to me. And consider supporting me. That protects you from me getting ill and abandoning this project involuntarily. Thank you!\r\n\r\n## SBOM\r\nAt the moment, the SBOM is stored here: https://github.com/stephanrauh/ngx-extended-pdf-viewer/blob/main/sbom.json. I'll package it with the library soon.\r\n\r\n## Known vulnerabilities\r\nPlease update to the latest version! At miminum, that should be version 20.0.2, but it's better to opt for the latest version because it contains the latest bugfixes.\r\n\r\nUntil 20.0.1 the PDF viewer was affected by [CVE-2024-4367](https://github.com/advisories/GHSA-wgrm-67xf-hhpq). Version 20.0.2 fixes this."
  },
  {
    "title": "Getting Started",
    "route": "/basics/getting-started/",
    "content": "## Prequisites and announcement\r\n\r\nYou can get the PDF viewer up and running in roughly two minutes. You need node.js, npm and a current version of Angular. This library aims to be compatible to the last four versions of Angular, which gives you two years time to update.\r\n\r\nWith very few exceptions, I only maintain the most current version of the viewer. As much as I'd like to provide bug fixes to older versions, I don't have enough time to spare.\r\n\r\n## Just in case you haven't got an Angular project yet\r\n\r\nThe instructions below assume you've already got an Angular project. If you haven't, here's what to do:\r\n\r\n- Install node.js. Make sure it's a current version with an even version number.\r\n- Install the Angular CLI by running the command `npm i -g @angular/cli`.\r\n- Create a new Angular app by running the command `ng new my-favorite-project`.\r\n\r\nI've described these steps in more detail <a href=\"https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/2010#issuecomment-1850778118\">here</a>.\r\n\r\n## Setting up the PDF viewer\r\n\r\n### Schematics (recommended)\r\n\r\n1. Open a terminal and navigate to the root folder of your project.\r\n2. Run this command and accept the defaults:\r\n```batch\r\nng add ngx-extended-pdf-viewer@latest\r\n``` \r\n3. If you need a specific version of ngx-extended-pdf-viewer, replace `@latest` by the version number you need. `@latest` gets you the newest stable version. If you omit `@latest`, Angular tries to detect the latest compatible version. Note that this may be an alpha version. Usually these alpha version are useful, too, but they ship without promises. By definition, an alpha version is a version that might be broken.\r\n4. Add the new component `<app-example-pdf-viewer>` to your `<app-component>` to display the PDF file.\r\n\r\nAfter that, you'll probably want to delete the example PDF file and move the code out of the example component.\r\n\r\n### Angular CLI\r\n\r\nInstall the library with `npm install`:\r\n\r\n```batch\r\nnpm i ngx-extended-pdf-viewer --save\r\n```\r\n\r\nNext, open the file `angular.json` (or `.angular-cli.json` if you're using an older version of Angular) and configure Angular to copy the `assets` folder of the library into the `assets` folder of your application:\r\n\r\n```json\r\n  \"assets\": [\r\n    \"src/favicon.ico\",\r\n    \"src/assets\",\r\n    {\r\n      \"glob\": \"**/*\",\r\n      \"input\": \"node_modules/ngx-extended-pdf-viewer/assets/\",\r\n      \"output\": \"/assets/\"\r\n    }\r\n  ],\r\n  \"scripts\": []\r\n```\r\n\r\nThis simply copies the entire assets folder. If you're concerned about disk memory, you can omit the subfolder `additional-locale`. If you need only one language, you can reduce the list to `locale.json` and your language folder.\r\n\r\n_Hint:_ There are two ways to define the language files needed for the labels of the buttons and screen elements of the PDF viewer. The second method is described below in the \"internationalization\" section.\r\n\r\nYou can choose between the stable release of pdf.js or the \"bleeding edge\" version. That latter is a version I regularly update with the newest changes from the Mozilla team. But be warned, the developer version is bleeding edge. It's a far cry from being a thoroughly tested release. The automated tests at Mozilla are fairly good, but it's always possible I do a mistake when merging the changes.\r\n\r\nIf you want to use the \"bleeding edge\" version of pdf.js, add these lines:\r\n\r\n```json\r\n  \"assets\": [\r\n    \"src/favicon.ico\",\r\n    \"src/assets\",\r\n    {\r\n      \"glob\": \"**/*\",\r\n      \"input\": \"node_modules/ngx-extended-pdf-viewer/bleeding-edge/\",\r\n      \"output\": \"/bleeding-edge/\"\r\n    }\r\n  ],\r\n  \"scripts\": []\r\n```\r\n\r\n\r\nYou will also need to add those lines to your component :\r\n1. An import statement\r\n```ts\r\nimport { pdfDefaultOptions } from 'ngx-extended-pdf-viewer';\r\n```\r\n2. A line in your constructor\r\n```ts \r\npdfDefaultOptions.assetsFolder = 'bleeding-edge';\r\n```\r\n\r\n#### Almost there!\r\n\r\nAdd `NgxExtendedPdfViewerModule` to the import section of your module file. If your IDE doesn't find\r\nthe import automatically, here it is:\r\n\r\n```typescript\r\nimport { NgxExtendedPdfViewerModule } from 'ngx-extended-pdf-viewer';\r\n```\r\n\r\nNow you can display the PDF file like so:\r\n\r\n```html\r\n\"tr<ngx-extended-pdf-viewer [src]=\"'assets/example.pdf'\"></ngx-extended-pdf-viewer>\r\n```\r\n\r\n### JHipster 6.6 + ngx-extended-pdf-viewer 2.0.0+\r\n\r\n**Caveat**: I don't support non-standard installations. This includes JHipster. Nonetheless, I've collected some hint that might help you get the PDF viewer up and running.\r\n\r\n**Hint**: There's a demo repository featuring JHipster 6.6 and ngx-extended-pdf-viewer 2.0.0-alpha.0 at\r\n<a target=\"#\" href=\"https://github.com/stephanrauh/PDF-Hipster\">https://github.com/stephanrauh/PDF-Hipster</a>.\r\n\r\nLocate the `CopyWebpackPlugin` in the file `webpack.common.js` (currently line 66-75) and add this line:\r\n\r\n```javascript\r\nnew CopyWebpackPlugin([\r\n  { from: \"./node_modules/ngx-extended-pdf-viewer/assets\", to: 'assets' },\r\n  ...\r\n```\r\n\r\n#### Almost there!\r\n\r\nAdd `NgxExtendedPdfViewerModule` to the import section of your module file. If your IDE doesn't find\r\nthe import automatically, here it is:\r\n\r\n```typescript\r\nimport { NgxExtendedPdfViewerModule } from 'ngx-extended-pdf-viewer';\r\n```\r\n\r\nNow you can display the PDF file like so:\r\n\r\n```html\r\n<ngx-extended-pdf-viewer [src]=\"'assets/example.pdf'\"></ngx-extended-pdf-viewer>\r\n```\r\n\r\n_Hint:_ If you are using JHipster, note there's no `assets` folder, so most likely the path of the URL is something like `[src]=\"'content/example.pdf'\"`.\r\n\r\n\r\n### older JHipster or Webpack\r\n\r\n**Caveat**: I don't support non-standard installations. This includes JHipster. Nonetheless, I've collected some hint that might help you get the PDF viewer up and running.\r\n\r\n1. Install the library with `npm install`:\r\n\r\n```batch\r\nnpm i ngx-extended-pdf-viewer --save\r\n```\r\n\r\n\r\n1. Locate the `CopyWebpackPlugin` in the file `webpack.common.js` (currently line 70) and add this line:\r\n\r\n```javascript\r\nnew CopyWebpackPlugin([\r\n  { from: \"./node_modules/ngx-extended-pdf-viewer/assets/locale\", to: 'content/assets/locale' },\r\n```\r\n\r\n2. Copy the files\r\n- `node_modules/ngx-extended-pdf-viewer/assets/pdf.worker.min.js` and\r\n- `node_modules/ngx-extended-pdf-viewer/assets/pdf.min.js`\r\n  manually to `src/main/webcontent/app`.\r\n\r\n3. Copy the file `node_modules/ngx-extended-pdf-viewer/assets/viewer.min.js` manually to a new folder `src/main/webcontent/app/web`.\r\n\r\n4. Add these lines to the imports section of the `app.main.ts` file:\r\n\r\n```typescript\r\nrequire('ngx-extended-pdf-viewer/assets/pdf.min.js');\r\nrequire('ngx-extended-pdf-viewer/assets/pdf.worker.min.js');\r\nrequire('ngx-extended-pdf-viewer/assets/web/viewer.min.js');\r\n```\r\n\r\n5. If you want to support Internet Explorer 11 and some other older browsers, also copy the ES5 version of these files:\r\n- `node_modules/ngx-extended-pdf-viewer/assets/pdf.worker-es5.min.js` and\r\n- `node_modules/ngx-extended-pdf-viewer/assets/pdf-es5.min.js`\r\n- `node_modules/ngx-extended-pdf-viewer/assets/viewer-es5.min.js`\r\n\r\n6. If you need to debug the PDF viewer, you may want to use the non-minified versions of these files: `pdf.worker.js`, `pdf.js`, and `viewer.js`.\r\n\r\n7. Open the freshly copied pdf.js file, locate the function `webpackUniversalModuleDefinition()` and replace the first ten lines by this version:\r\n\r\n```typescript\r\n(function webpackUniversalModuleDefinition(root, factory) {\r\n  if(typeof exports === 'object' && typeof module === 'object')\r\n    module.exports = factory();\r\n  else if(typeof define === 'function' && define.amd)\r\n    define(\"pdfjs-dist/build/pdf\", [], factory);\r\n  else if(typeof exports === 'object')\r\n    exports[\"pdfjs-dist/build/pdf\"] = factory();\r\n  // else <-- delete line\r\n  window[\"pdfjs-dist/build/pdf\"] = root[\"pdfjs-dist/build/pdf\"] = root.pdfjsLib = factory(); // <-- modified line\r\n})(this, function() {\r\n```\r\n\r\n#### Almost there!\r\n\r\nAdd `NgxExtendedPdfViewerModule` to the import section of your module file. If your IDE doesn't find \r\nthe import automatically, here it is:\r\n\r\n```typescript\r\nimport { NgxExtendedPdfViewerModule } from 'ngx-extended-pdf-viewer';\r\n```\r\n\r\nNow you can display the PDF file like so:\r\n\r\n```html\r\n<ngx-extended-pdf-viewer [src]=\"'assets/example.pdf'\"></ngx-extended-pdf-viewer>\r\n```\r\n\r\n_Hint:_ If you are using JHipster, note there's no `assets` folder, so most likely the path of the URL is something like `[src]=\"'content/example.pdf'\"`.\r\n\r\n\r\n### Still got difficulties?\r\n\r\nPlease refer to the [troubleshooting page](/troubleshooting)"
  },
  {
    "title": "Image",
    "route": "/exporting/image/",
    "content": "You can export the PDF file as an image. Note that the text of the PDF usually scales smoothlessly; you can print it with high resolution. However, the images embedded in the PDF file usually don't scale as gracefully.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n    [src]=\"'/assets/pdfs/blind-text-collection.pdf'\"\r\n    [textLayer]=\"true\" <!-- enable the find button -->\r\n    [showHandToolButton]=\"true\" <!-- enable text selection -->\r\n    [height]=\"'90vh'\"> <!-- by default, most CSS frameworks set the height to 0 -->\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\nconstructor(private pdfViewerService: NgxExtendedPdfViewerService) {}\r\n\r\npublic exportAsImage(): void {\r\n  const scale = {width: this.width}; \r\n  // or: scale = {height: this.height};\r\n  // or: scale = {scale: this.scale};\r\n  this.pdfViewerService.getPageAsImage(1, scale, (dataURL) =>\r\n    this.showImage(dataURL)\r\n  );\r\n}\r\n\r\nprivate showImage(dataURL: any): void {\r\n  this.imageDataURL = dataURL;\r\n  this.getImageDimensions(dataURL);\r\n}\r\n\r\nprivate getImageDimensions(dataURL: string): void {\r\n  const i = new Image();\r\n  i.onload = () => {\r\n    this.widthDisplay = i.width;\r\n    this.heightDisplay = i.height;\r\n  };\r\n  i.src = dataURL;\r\n}\r\n```"
  },
  {
    "title": "Internationalization",
    "route": "/configuration/internationalization/",
    "content": "## Using a specific language\r\n\r\n`ngx-extended-pdf-viewer` ships with translation for more than 100 languages and dialects. When you copy the `node_modules/ngx-extended-pdf-viewer/assets/locale` folder to the `assets/locale` folder of your application, you can select your language by setting the `language` attribute. If you omit this attribute, the default locale of the browser is used.\r\n\r\n**Note**: The `language` attribute is only read when the component is drawn initially. Switching a language at runtime requires hiding the viewer shortly or reloading it.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer [src]=\"'/assets/pdfs/BootsFaces_Deep_Dive_1.0.pdf'\" backgroundColor=\"#ffffff\" [language]=\"language\" textLayer=\"true\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\n@Component({ ... })\r\nexport class I18nComponent {\r\n  public hidePdfViewer = false;\r\n\r\n  private _language = 'es-ES';\r\n\r\n  public get language(): string {\r\n    return this._language;\r\n  }\r\n\r\n  public set language(language: string) {\r\n    this._language = language;\r\n    this.hidePdfViewer = true;\r\n    // the timeout gives the PDF viewer time\r\n    // to free memory\r\n    setTimeout(() => {\r\n      this.hidePdfViewer = false;\r\n    }, 100);\r\n  }\r\n}\r\n```\r\n\r\n## Custom Translations\r\n\r\nTo use custom translations, copy the viewer.ftl file you want to modify from the `node_module/ngx-extended-pdf-viewer` folder into your project. Then modify it and add a rule to your `angular.json` ensuring the original file is overwritten each time your compile your application.\r\n\r\n**Caveat**: Every once in a while, the team at Mozilla or - less frequently - I add a translation. When you modify the default translation, please check the new changes with each major version of pdf.js.\r\n\r\n### angular.json\r\n\r\n```json\r\n...\r\n\"assets\": [\r\n  \"src/server.js\",\r\n  \"src/.htaccess\",\r\n  \"src/favicon.ico\",\r\n  \"src/assets\",\r\n  {\r\n    \"glob\": \"**/*\",\r\n    \"input\": \"node_modules/ngx-extended-pdf-viewer/assets\",\r\n    \"output\": \"/assets/\"\r\n  },\r\n  // new rule follows here:\r\n  {\r\n    \"glob\": \"**/*\",\r\n    \"input\": \"src/assets/i18n\",\r\n    \"output\": \"/assets/locale/\"\r\n  },\r\n...\r\n```\r\n\r\n### viewer.ftl\r\n\r\n```\r\n...\r\npdfjs-page-scale-actual = Taille réelle\r\n# Variables:\r\n#   $scale (Number) - percent value for page scale\r\n# Here's the change:\r\npdfjs-page-scale-percent = { $scale } per cent\r\n...\r\n```"
  },
  {
    "title": "Internationalization",
    "route": "/viewing/internationalization/",
    "content": "`ngx-extended-pdf-viewer` ships with translation for more than 100 languages and dialects. When you copy the `node_modules/ngx-extended-pdf-viewer/assets/locale` folder to the `assets/locale folder` of your application, you can select your language by setting the `[language]` attribute. If you omit this attribute, the default locale of the browser is used.\r\n\r\n**Caveat**: The attribute \"language\" is only read when the component is drawn initially. So this demo hides the PDF viewer for a second when you're switching from one language to another.\r\n\r\n## HTML\r\n\r\n```html\r\n <ngx-extended-pdf-viewer\r\n  src=\"/assets/pdfs/BootsFaces_Deep_Dive_1.0.pdf\"\r\n  [textLayer]=\"true\"\r\n  language=\"fr\"\r\n>\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## Custom Translations\r\n\r\nYou can even use custom translations for your PDF Viewer.\r\n\r\nTo achieve this, copy the `viewer.ftl` file you want to modify from the `node_module/ngx-extended-pdf-viewer` folder into your project, modify it, add a rule to your `angular.json` ensuring the original file is overwritten each time your compile your application.\r\n\r\n**Caveat**: Every once in a while, the team at Mozilla or - less frequently - I add a translation. When you modify the default translation, please check the new changes with each major version of pdf.js.\r\n\r\n### angular.json\r\n```json\r\n...\r\n\"assets\": [\r\n  \"src/server.js\",\r\n  \"src/.htaccess\",\r\n  \"src/favicon.ico\",\r\n  \"src/assets\",\r\n  {\r\n    \"glob\": \"**/*\",\r\n    \"input\": \"node_modules/ngx-extended-pdf-viewer/assets\",\r\n    \"output\": \"/assets/\"\r\n  },\r\n  // new rule follows here:\r\n  {\r\n    \"glob\": \"**/*\",\r\n    \"input\": \"src/assets/i18n\",\r\n    \"output\": \"/assets/locale/\"\r\n  },\r\n...\r\n```\r\n\r\n### viewer.ftl\r\n\r\nFrench example at `assets/i18n/fr/viewer.ftl`\r\n\r\n```\r\n...\r\npdfjs-page-scale-actual = Taille réelle\r\n# Variables:\r\n#   $scale (Number) - percent value for page scale\r\n# Here's the change:\r\npdfjs-page-scale-percent = { $scale } per cent\r\n...\r\n```"
  },
  {
    "title": "Intro",
    "route": "/about/intro/",
    "content": "## What is &lt;ngx-extended-pdf-viewer&gt;?\r\n\r\nWe all know the Adobe's PDF viewer. Almost certainly you've also seen PDF documents in a browser. Every modern browser supports PDF files natively.\r\n\r\n`<ngx-extended-pdf-viewer>` brings precisely this browser to the Angular world. When I started to investigate the topic, I quickly learned that it's not easy to display a PDF file natively. There are ways to do it - but if you want to implement an application running on all platforms, things get difficult in virtually no time. Especially if you need to support Internet Explorer 11.\r\n\r\nThis project simply wraps Mozilla's PDF viewer as an Angular component. It's the same PDF viewer both Google Chrome and Mozilla Firefox use. In other words: it uses a battle-proven, rock-solid technology.\r\n\r\n## Talking about the memory footprint: how bad is it?\r\n\r\nThere's no point denying it: viewing PDF files comes with a huge memory penalty. Mozilla's PDF viewer consists of four files, weighing in at roughly two megabytes. Minification and Gzip reduce this to roughly half a megabyte.\r\n\r\nHowever, almost every alternative I know also relies on Mozilla's PDF viewer, so you get a similar memory and bandwidth penalty.\r\n\r\n## Is pdfviewer.net open to document other PDF viewers?\r\n\r\nYes, of course. At the moment I focus on my own project. In the long run, I intend to include other PDF viewer as well as approaches to view PDF natively in the browser."
  },
  {
    "title": "Javascript",
    "route": "/configuration/javascript/",
    "content": "## Disabling JavaScript\r\n\r\npdf.js ships with a JavaScript engine. There's little security risk because they're executing JavaScript in a sandbox. Even so, you can deactivate scripting altogether.\r\n\r\nIf you want to deactivate the JavaScript engine, keep two things in mind:\r\n\r\n- You must disable JavaScript before loading the pdf.js engine. Usually initializing pdfDefaultOptions.enableScripting = false; in the constructor of your component is early enough (unless you've already opened a PDF document before).\r\n- If your PDF file contains a script to print the file immediately after opening it, it's still printed. The only difference is it's not printed using the JavaScript engine, so any option your JavaScript code may pass is lost.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/160F-2019.pdf'\"\r\n  [height]=\"'auto'\"\r\n>\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\n@Component({ ... })\r\nexport class ContextmenuComponent {\r\n  constructor() {\r\n    pdfDefaultOptions.enableScripting = false;\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Keyboard",
    "route": "/configuration/keyboard/",
    "content": "The PDF viewer can be controlled by the keyboard. If necessary, you can disable the key bindings, either globally or only certain keys.\r\n\r\n- `[ignoreKeyboard]=\"true\"`: disables the keyboard entirely\r\n- `[ignoreKeys]` comma-separated list of keys. Every key in the list is ignored.\r\n- `[acceptKeys]` comma-separated list of keys. Every key in the list is accepted, and every other key is ignored.\r\n\r\nThe keys are defined by their name and - optionally - their modifiers (`SHIFT`, `ALT`, `CTRL`, `CMD`, and `META`). CMD is used on Apple keyboards, while META is used on some UNIX keyboards.\r\n\r\nExamples: `CTRL+SHIFT+P` is the key binding of the presentation mode. `F4` toggles the sidebar.\r\n\r\n### HTML\r\n\r\n```html\r\n  <ngx-extended-pdf-viewer\r\n    src=\"/assets/pdfs/hammond-organ-wikipedia.pdf\"\r\n    [ignoreKeyboard]=\"false\"\r\n    [ignoreKeys]=\"['J', 'K', 'F4']\"\r\n    [acceptKeys]=\"[]\"\r\n    [showPresentationModeButton]=\"true\">\r\n  </ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\n@Component({ ... })\r\nexport class KeyboardComponent implements OnInit {\r\n  public ignoreKeyboard = false;\r\n  public acceptKeys = ['J', 'K', 'F$'];\r\n  public ignoreKeys = [];\r\n}\r\n```"
  },
  {
    "title": "Links",
    "route": "/configuration/links/",
    "content": "## Description\r\n\r\nThere are several kinds of links:\r\n\r\n- Internal links within the PDF files.\r\n- External links on web server (usually with an https URL).\r\n- Links to file on the local PC or the local network. The PDF viewer doesn't support such links.\r\n\r\nBy default, external links are opened in the same window. In other words, clicking the link amounts to leaving the Angular application. To prevent this, you have two options:\r\n\r\n- Add the target when you're creating the PDF file. That's generally the best solution.\r\n- Use the defaultOptions to override the default for externalLinkTarget.\r\n\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer *ngIf=\"!hidden\"\r\n  [src]=\"'/assets/pdfs/blind-text-collection.pdf'\"\r\n  backgroundColor=\"#ffffff\"\r\n  [height]=\"'90vh'\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n\r\n### TypeScript\r\n\r\n```typescript\r\nimport { pdfDefaultOptions } from 'ngx-extended-pdf-viewer/default-options';\r\nimport { LinkTarget } from 'ngx-extended-pdf-viewer';\r\n...\r\nngOnInit(): void {\r\n  pdfDefaultOptions.externalLinkTarget = LinkTarget.BLANK;\r\n}\r\n```\r\n\r\n\r\n## Default Link Targets\r\n\r\nThe link target is only considered at render time. Changing it at runtime requires a reload of the PDF Viewer.\r\n\r\n- LinkTarget.BLANK\r\n  - opens a new window\r\n- LinkTarget.SELF\r\n  - opens in same window\r\n- LinkTarget.PARENT\r\n  - opens in same window\r\n- LinkTarget.TOP\r\n  - opens in same window\r\n- LinkTarget.NONE\r\n  - opens in same window\r\n\r\n\r\n## Deactivating Links\r\n\r\nYou can manipulate links using the `pageRendered` event. Note you can't modify the appearance of the links. They are part of the PDF file, so they can't be displayed differently. But you can modify the invisible annotation layer.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer *ngIf=\"!hidden\"\r\n  [src]=\"'/assets/pdfs/blind-text-collection.pdf'\"\r\n  [height]=\"'90vh'\"\r\n  (pageRendered)=\"afterPageRendered($event)\"\r\n>\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n```typescript\r\nexport class LinksComponent {\r\n public afterPageRendered(pageRenderedEvent: PageRenderedEvent) {\r\n    const pageView = pageRenderedEvent.source; /* as PdfPageView */\r\n    const div = pageView.div as HTMLDivElement;\r\n    div.querySelectorAll('a').forEach((a: HTMLAnchorElement) => {\r\n      a.href = 'javascript: void(0)';\r\n      a.target = '';\r\n    });\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Menus",
    "route": "/customization/menus/",
    "content": "## Findbar\r\n\r\nThe findbar becomes visible after hitting `CTRL+F`."
  },
  {
    "title": "Menus",
    "route": "/customization/menus/",
    "content": "## Secondary menu (before version 18)\r\n\r\n**Important:** This section describes how the seondary menu worked in older versions. The old customizations should still work in version 18+, but I recommend migrating to the new approach because it's both simpler and more flexible.\r\n\r\nThe secondary toolbar is the menu that opens on the right-hand side. It contains many buttons of the primary toolbar. On small displays, widgets are shifted from the primary toolbar to the secondary toolbar until the primary toolbar fits on the screen. Similarly, when the window size gets larger, many items are shifted from the secondary toolbar to the primary toolbar."
  },
  {
    "title": "Menus",
    "route": "/customization/menus/",
    "content": "## Secondary menu (since version 18)\r\n\r\nSince version 18, almost every button is able to move dynamically from the toolbar to the secondary menu. The idea is to move buttons from the toolbar to the secondary menu until the toolbar fits on the screen, so small displays can still show all buttons.\r\n\r\nEvery toolbar button has a `show<ButtonName>` attribute which defines the breakpoint of the button. If the screen is wider than the breakpoint, the button is displayed in the toolbar. Otherwise it's displayed in the secondary menu. There are also two special values: `always-visible` means the button is never moved to the secondary menu. Conversely, `always-in-secondary-menu` means the button always hides in the secondary menu.\r\n\r\nThere's an interactive live-demo at the [responsive design page](./customization/responsive-design) of this showcase.\r\n\r\nIf you use the `<pdf-shy-button>` component to define your custom buttons they also benefit from responsive design. However, there's a catch: if you're using the `<pdf-shy-button>`, you can use the `action` attribute to define custom logic. Basically, the `action` attribute is treated like a fat arrow function - and that means it's inheriting the `this` reference from the `PdfShyButton` class. The constructor of your button component is never called, and neither is `ngOnInit`. Probably that sounds more confusing than it is, so don't worry - it's easy to implement custom \"shy\" buttons. Just keep in mind that this is not what you might expect.\r\n\r\n\r\n### Adding custom buttons to the toolbar and/or the secondary menu\r\n\r\nThe `<pdf-shy-button>` allows you to benefit from seamless integration into the toolbar and the secondary menu. A typical shy button looks like so:\r\n\r\n```html\r\n<pdf-shy-button\r\n  [cssClass]=\"'always-in-secondary-menu' | responsiveCSSClass\"\r\n  title=\"Infinite scroll\"\r\n  primaryToolbarId=\"infiniteScroll\"\r\n  l10nId=\"infinite_scroll\"\r\n  [toggled]=\"pageViewMode == 'infinite-scroll'\"\r\n  [action]=\"onClick\"\r\n  l10nLabel=\"pdfjs-infinite-scroll-button-label\"\r\n  [order]=\"3400\"\r\n  [closeOnClick]=\"false\"\r\n  image=\"<svg xmlns='http://www.w3.org/2000/svg' \r\n          height= '24' viewBox= '0 -960 960 960' \r\n          width='24'>\r\n           <path d= '...'/>\r\n         </svg>\"\r\n>\r\n</pdf-shy-button>\r\n```\r\n\r\nThe clumsy `[cssClass]` definition allows you to define the breakpoint using a shortcut. Legal values are `always-visible` , `always-in-secondary-menu` , `xxs` , `xs` , `sm` , `md` , `lg` , `xl` , and `xxl`. `xxl` means the button is only visible in the toolbar on very large screens, while `xxs` means it's visible on fairly small screens.\r\n\r\nThe two `l10n` attributes use the translation tables of pdf.js. They're useless for you unless you can use one of the pre-defined texts of the viewer.properties file. In most cases, `[title]` should to the trick just as well.\r\n\r\n`[order]` determines where the button appears in the secondary menu. The default buttons use increments of 100, so you can insert 99 custom menu items between two default menu items. If the button shows in the toolbar, its position is determined by the position in the source code (plus CSS - in other words, it's exactly the behavior you'd expect).\r\n\r\nThe `[action]` attribute is a bit tricky. You can't use this in the event listener method because the event listener is used both for the toolbar (`this` is available here) and the secondary menu (`this` is undefined here). I'm sure I've selected a clumsy solution, but here's my current approach:\r\n\r\n```typescript\r\nexport class PdfInfiniteScrollComponent implements OnDestroy {\r\n  @Input() \r\n  public pageViewMode: PageViewModeType;\r\n\r\n  @Output()\r\n  public pageViewModeChange = new EventEmitter<PageViewModeType>();\r\n\r\n  public onClick?: () => void;\r\n\r\n  constructor() {\r\n    const emitter = this.pageViewModeChange;\r\n    this.onClick = () => {\r\n      setTimeout(() => {\r\n           emitter.emit('infinite-scroll');\r\n      });\r\n    };\r\n  }\r\n\r\n  public ngOnDestroy(): void {\r\n    this.onClick = undefined;\r\n  }\r\n}\r\n```\r\n\r\nThe key idea is to define the event listener in the constructor, where you can capture this in a constant."
  },
  {
    "title": "Menus",
    "route": "/customization/menus/",
    "content": "`<ngx-extended-pdf-viewer>` allows you to customize the toolbar and the menu of the PDF viewer. \r\n\r\nYou can:\r\n\r\n- re-arrange the pre-defined items any way you like\r\n- replace existing items by custom items - including your own icons, texts, and tooltips\r\n- and add your own buttons, menu items, and even menus, implementing custom functions I can't even imagine\r\n\r\n**But how to document this feature?**\r\n\r\nI'm afraid you can't avoid reading the sourcecode of the UI. You find it in the [GitHub repository of ngx-extended-pdf-viewer](https://github.com/stephanrauh/ngx-extended-pdf-viewer/blob/main/projects/ngx-extended-pdf-viewer/src/lib/ngx-extended-pdf-viewer.component.html).\r\n\r\n\r\nNonetheless, I'm optimistic I can give you a head start with a couple of demos and a few hints:\r\n\r\n- First of all, this [interactive demo](./customization/toolbar) shows a few example implementations.\r\n- The default UI naturally forms a tree. Below, you'll find a high-level abstraction of this tree. Your customization doesn't have to follow this structure. It's just the default.\r\n- The customization hooks defined by <ngx-extended-pdf-viewer> allow you to modify certain subtrees. Currently there are nine hooks:\r\n  - `[customToolbar]` allows you to modify the entire black bar above the PDF document.\r\n  - `[customFreeFloatingBar]` allows you to add your own toolbar. The original use-case is a toolbar floating above the PDF file. But if you're familiar with CSS magic, you're probably not limited to that.\r\n  - `[customSecondaryToolbar]` represents the menu at the right-hand side of the PDF viewer.\r\n  - `[customFindbar]` allows you to define your own findbar.\r\n  - `[customFindbarButtons]` allows you to modify the entire find bar (the black bar that's shown after typing CTRL+F).\r\n  - `[customFindbarInputArea]` is responsible for a small part of the find bar: the input field and the previous/next buttons.\r\n  - `[customSidebar]` defines your own sidebar. See the [custom sidebar demo](./customization/sidebar).\r\n  - `[customThumbnail]` See the [custom thumbnails demo](./customization/thumbnails).\r\n  - `[customPdfViewer]` is your door to modify everything except the CSS imports.\r\n- The underlying PDF framework, pdf.js, recognizes the buttons and menu items by their id. If you want to modify an existing functionality, keep in mind you have to provide the id. Otherwise, pdf.js might raise an exception, and your custom button won't work.\r\n- However, most buttons are component you can either use or copy. You can see the full list of toolbar buttons in the [GitHub repository of ngx-extended-pdf-viewer](https://github.com/stephanrauh/ngx-extended-pdf-viewer/blob/main/projects/ngx-extended-pdf-viewer/src/lib/toolbar/pdf-toolbar/pdf-toolbar.component.html).\r\n- I'm sure there's a lot of headroom for improvements. Don't hesitate to report any shortcoming on the [bugtracker of ngx-extended-pdf-viewer](https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues)."
  },
  {
    "title": "Menus",
    "route": "/customization/menus/",
    "content": "## Toolbar\r\n\r\nThe toolbar is the black bar containing the buttons above the PDF file.\r\n\r\n**Legend:** The red text tells you which id the component renders internally. When you use the component, don't add the id. Otherwise, the id is used twice. In many cases, this causes errors. However, since version 18, most buttons replaced the pdf.js implementation by an Angular implementation, so the ids aren't as important as they used to be in earlier versions.\r\n\r\n**Breaking Change in version 22:** Some of the ids have changed: #print is now #printButton, and #download is now #downloadButton."
  },
  {
    "title": "Mobile Devices",
    "route": "/viewing/mobile-devices/",
    "content": "On mobile devices, like a tiny smartphone, all the buttons are pushed to the secondary menu. That's most inconvenient, so chances are you want to put a small selection of buttons into the toolbar. The recommended way to do so is to define a custom toolbar.\r\n\r\nHowever, you can also use CSS rules to do the trick. Don't forget to set `ignoreResponsiveCSS=\"true\"`. Otherwise, your CSS rules will be overwritten by JavaScript.\r\n\r\n**Caveat**: the selector `::ng-deep` is deprecated and will be removed soon. As far as I know, the only replacement is putting the CSS rules into the global styles.css file. Also note that the `!important` bit is important. You can't avoid it because the CSS class .hidden already bears the `!important` tag.\r\n\r\n## CSS\r\n\r\n```css\r\n/* deep/ /is deprecated, so move this to the global styles.css if possible! */\r\n::ng-deep button#printButton,\r\n::ng-deep button#printButton * {\r\n  display: block !important;\r\n}\r\n\r\n::ng-deep button#download,\r\n::ng-deep button#download * {\r\n  display: block !important;\r\n}\r\n\r\n::ng-deep #toolbarViewerMiddle {\r\n  display: none;\r\n}\r\n```\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/A COOL KID LIKE ME.pdf.pdf'\"\r\n  [height]=\"'667px'\"\r\n  backgroundColor=\"#ffffff\"\r\n  [mobileFriendlyZoom]=\"'150%'\"\r\n  [showSecondaryToolbarButton]=\"false\"\r\n>\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class MobileComponent {\r\n  public mobileFriendlyZoomSetting = '150%';\r\n}\r\n```"
  },
  {
    "title": "Modal Dialogs",
    "route": "/configuration/modal-dialogs/",
    "content": "Modal dialogs often remove the HTML code from the DOM before calling `ngOnDestroy()` of the `NgxExtendedPdfViewerComponent`, resulting in a couple of error messages on the console. To avoid this, call `ngOnDestroy()` manually before removing the HTML code. The demo shows how to do this with the Angular CDK dialog.\r\n\r\nIf you close the modal very quickly, you may see messages like \"worker destroyed\" or \"transport destroyed\" in the console log. This simply means that you've destroyed the PDF viewer while it's still rendering. If you need to get rid of these messages, register a custom [`globalThis.ngxConsoleFilter(logLevel, message)`](./developer-experience/filtering-console-log).\r\n\r\n### TypeScript\r\n\r\n```typescript\r\n@Component({\r\n  selector: 'app-modal-dialog',\r\n  templateUrl: './modal-dialog.component.html'\r\n})\r\nexport class ModalDialogComponent implements OnInit {\r\n  private dialogRef = inject<DialogRef<void>>(DialogRef<void>);\r\n  private pdfViewer = viewChild.required(NgxExtendedPdfViewerComponent);\r\n\r\n  ngOnInit() {\r\n    this.dialogRef.closed.subscribe((result) => {\r\n      console.log('The dialog is about to be closed');\r\n      // Here's the interesting bit:\r\n      this.pdfViewer().ngOnDestroy();\r\n    });\r\n  }\r\n\r\n  public onClose(): void {\r\n    this.dialogRef.close();\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Multiple Pdfs",
    "route": "/viewing/multiple-pdfs/",
    "content": "To display multiple PDF files on the same page, you need to put them in an iFrame.\r\n\r\nIn the long run, I plan to fix this, so you can put two instances of ngx-extended-pdf-viewer side-by-side without using an iFrame. Unfortunately, this requires a lot of changes to the library, so it'll take a while. The good news is the base library, pdf.js, already allows it.\r\n\r\nThe work-around looks like so:\r\n\r\n<ul>\r\n<li>You define an URL in the router that shows the PDF viewer (and nothing else). In the example below, the URL renders the <code>iFrameComponent</code>.</li>\r\n<li>Instead of adding the instances of <code><ngx-extended-pdf-viewer></code> to your HTML template, add an iFrame pointing to this special URL.</li>\r\n</ul>\r\n\r\n## IFrame Component\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer [src]=\"url\" [zoom]=\"'auto'\"> </ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\n@Component({\r\n  standalone: false,\r\n  selector: 'app-iframe',\r\n  templateUrl: './iframe.component.html',\r\n  styleUrls: ['./iframe.component.css'],\r\n})\r\nexport class IFrameComponent {\r\n  public url: string;\r\n  constructor() {\r\n    if (location.pathname.endsWith('cdk')) {\r\n      this.url = '/assets/pdfs/CDK.pdf';\r\n    } else {\r\n      this.url = '/assets/pdfs/GraalVM.pdf';\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Using the IFrame Component\r\n\r\n```html\r\n<div style=\"width: 100%\">\r\n  <iframe id=\"embedded\" src=\"/extended-pdf-viewer/iframe/cdk\" style=\"height: 100vh; width: 47%\"></iframe>\r\n  <iframe id=\"embedded\" src=\"/extended-pdf-viewer/iframe/graalvm\" style=\"height: 100vh; width: 47%; float: right\"></iframe>\r\n</div>\r\n```"
  },
  {
    "title": "Navigation Api",
    "route": "/developer-experience/navigation-api/",
    "content": "The attribute `[namedDest]` allows you to navigate to a \"named destination\" of the PDF file.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'./assets/pdfs/latex.pdf'\"\r\n  [(page)]=\"page\"\r\n  [nameddest]=\"namedDest\"\r\n  [height]=\"'auto'\"\r\n>\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class NavigationComponent {\r\n  public _namedDest: string | undefined;\r\n  public page: number | undefined;\r\n\r\n  public get namedDest() {\r\n    return this._namedDest;\r\n  }\r\n\r\n  public set namedDest(dest: string | undefined) {\r\n    // reset the attribute to force change detection:\r\n    this._namedDest = undefined;\r\n    setTimeout(() => (this._namedDest = dest));\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Overview",
    "route": "/configuration/layers/overview/",
    "content": "## Types of layers\r\n\r\nThe PDF viewer always renders the PDF file as a canvas. Often, it also generates additional layers on top of the canvas.\r\n\r\nThose layers are\r\n- [Text Layer](./configuration/layers/text)\r\n- [Annotation Layer](./configuration/layers/annotation)\r\n- [PDF Layers](./configuration/layers/pdf)\r\n\r\nYou don't have to think much about these layers most of the time. However, these layers are HTML divs, and you can manipulate them."
  },
  {
    "title": "Passwords",
    "route": "/viewing/passwords/",
    "content": "To open a password-protected file, you can either have the user type the password or you can pass the password programmatically.\r\n\r\n## HTML\r\n\r\n```html\r\n <ngx-extended-pdf-viewer\r\n    [src]=\"src\"\r\n    [password]=\"password\"    \r\n    [height]=\"'auto'\"\r\n  >\r\n  </ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({\r\n  standalone: false, \r\n  selector: 'app-passwords',\r\n  templateUrl: './passwords.component.html',\r\n  styleUrls: ['./passwords.component.css']\r\n})\r\nexport class PasswordsComponent { \r\n  public password = \"graalvm-rocks!\";\r\n}\r\n```\r\n\r\n## Custom Dialog\r\n\r\nYou can also implement a custom password dialog and register it as a `pdfDefaultOption`. The dialog has to be an object implementing the interface `PasswordPrompt`. The demo implements a very simple custom password prompt: it simply uses the `confirm()` function.\r\n\r\n### TypeScript\r\n\r\n```typescript\r\nimport { PasswordPrompt } from \"ngx-extended-pdf-viewer\";\r\n\r\nexport class CustomPasswordPrompt implements PasswordPrompt {\r\n\r\n  private updateCallback!: (password: string) => void;\r\n\r\n  public open(): void {\r\n    if (confirm(\"Come on, GraalVM does not suck!\")) {\r\n      this.updateCallback(\"graalvm-rocks!\");\r\n    }\r\n  }\r\n\r\n  setUpdateCallback(updateCallback: (password: string) => void, reason: 1 | 2) {\r\n    this.updateCallback = updateCallback;\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Pdf",
    "route": "/configuration/layers/pdf/",
    "content": "`ngx-extended-pdf-viewer` supports layered PDF files. You can hide and show each layer in the new \"layers\" tab of the sidebar. This also works for hidden layers.\r\n\r\nThe editors of this PDF viewer use another layer to store you drawings and free-text.\r\n\r\n`ngxExtendedPdfViewerService` offers two methods allowing you to control the layers programmatically:\r\n- `listLayers()` yields a list of the layers. Don't call it too early. A good point in time is the event `(pagesLoaded)`.\r\n- `toggleLayer(id)` toggles a layer. You need to pass the ID of the layer. The ID, in turn, is part of the result of `listLayers()`.\r\n\r\nNote there's not two-way binding. The PDF viewer doesn't fire an event if the user toggles the layers in the PDF file. However, you can register a callback to a low-level API like so:\r\n\r\n```ts\r\nPDFViewerApplication.eventBus.on('optionalcontentconfig', callback)\r\n```\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n    [src]=\"'/assets/pdfs/themes_de_la_Science-fiction.pdf'\"\r\n    [height]=\"'90vh'\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\nexport class LayersComponent {\r\n\r\n  constructor(private pdfService: NgxExtendedPdfViewerService) {}\r\n\r\n  public async listLayers(): Promise<void> {\r\n    const l = await this.pdfService.listLayers();\r\n    if (l) {\r\n      this.layers = l;\r\n    }\r\n  }\r\n\r\n  public async toggle(layerId: string): Promise<void> {\r\n    await this.pdfService.toggleLayer(layerId);\r\n    await this.listLayers();\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Pdf Viewer",
    "route": "/contributing/pdf-viewer/",
    "content": "## New Page\r\n\r\nInsert new page content here"
  },
  {
    "title": "Pre Rendering",
    "route": "/configuration/pre-rendering/",
    "content": "Rendering a PDF page takes some time. When you browse quickly through the pages of a complex document, you'll frequently see the loading indicator instead of the page. That's an unpleasant experience, so the PDF viewer renders one or two pages in advance.\r\n\r\nWhile that's a good compromise between energy consumption and user experience in most cases, some users reported they need more flexibility. ngx-extended-pdf-viewer allows you to define a custom pre-rendering strategy. You can use it to render more pages below the current page in advance, but you can also use it to render pages above the currently visible page. The latter is useful to allow quick backward scrolling after jumping to a new chapter or jumping to a new page by entering the page number.\r\n\r\nNote that rendering too many pages in advance may have the opposite effect. Keeping your CPU busy results in a slow UI and a bad user experience.\r\n\r\n### Example Algorithm\r\n\r\nThe algorithm below increases the number of pre-rendered pages to two pages backward and up to five pages in advance.\r\n\r\n#### HTML\r\n\r\n```html\r\n <ngx-extended-pdf-viewer\r\n    [src]=\"'./assets/pdfs/The Public Domain - Enclosing the Commons of the Mind.pdf'\"\r\n    [zoom]=\"'page-width'\"\r\n    [height]=\"'auto'\"\r\n    [(page)]=\"page\"\r\n    [(pageLabel)]=\"pageLabel\"\r\n    [textLayer]=\"true\"\r\n    (pageRendered)=\"onPageRendered()\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n#### TypeScript\r\n\r\n```typescript\r\n @Component({ ... })\r\nexport class PrerenderingComponent {\r\n  public spreadMode: 'off' | 'even' | 'odd' = 'off';\r\n\r\n  constructor(private pdfViewerService: NgxExtendedPdfViewerService) {\r\n    pdfDefaultOptions.ignoreDestinationZoom = true;\r\n  }\r\n\r\n  public onPageRendered(): void {\r\n    if (!this.pdfViewerService.isRenderQueueEmpty()) {\r\n      // try again later when the pages requested by the pdf.js core or the user have been rendered\r\n      setTimeout(() => this.onPageRendered(), 100);\r\n    }\r\n\r\n    const pagesBefore = this.spreadMode === 'off' ? 2 : 2;\r\n    const pagesAfter = this.spreadMode === 'off' ? 2 : 5;\r\n    let startPage = Math.max(this.page - pagesBefore, 1);\r\n    let endPage = Math.min(this.page  + pagesAfter, this.pdfViewerService.numberOfPages());\r\n\r\n    const renderedPages = this.pdfViewerService.currentlyRenderedPages();\r\n\r\n    for (let page = startPage; page <= endPage; page++) {\r\n      const pageIndex = page - 1;\r\n      if (!this.pdfViewerService.hasPageBeenRendered(pageIndex)) {\r\n          this.pdfViewerService.addPageToRenderQueue(pageIndex);\r\n          break; // break because you can request only one page at a time\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n## Buffer for rendered pages\r\n\r\nIf you're running on tight memory constraints, you can reduce the size of the number of pre-rendered pages. By default, `ngx-extended-pdf-viewer` keeps up to 50 pages in memory. To reduce or increase this setting, set `pdfDefaultOptions.defaultCacheSize` to a different number."
  },
  {
    "title": "Presentation Mode",
    "route": "/viewing/presentation-mode/",
    "content": "The fullscreen mode of pdf.js (and, by extension, ngx-extended-pdf-viewer) is optimized for presentations. There's little else you can do with it: you can't scroll, nor can you zoom in or out.\r\n\r\nYou can't activate the full-screen mode programmatically. It must be triggered by the user."
  },
  {
    "title": "Print Api",
    "route": "/printing/print-api/",
    "content": "You can print the PDF file by calling `NgxExtendedPdfViewerService.print()`. The (optional) parameter defines the print range. Limiting the print range is useful for very large documents that'd crash your browser - such as trying to print documents containing several hundred pages with Internet Explorer 11.\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class PrintRangeComponent {\r\n  constructor(private printService: NgxExtendedPdfViewerService) {}\r\n\r\n  public print(): void {\r\n    const range: PDFPrintRange = {\r\n      from: 1,\r\n      to: 10,\r\n      excluded: [2, 4, 6, 8],\r\n    };\r\n    this.printService.print(range);\r\n  }\r\n}\r\n```\r\n\r\n## Setting Print Range\r\n\r\nCalling `NgxExtendedPdfViewerService.setPrintRange()` limits the print range of the print button and `CTRL+P`. This also includes the programmatic API `print()` if the parameter is omitted.\r\n\r\nTo prevent nasty surprises, implement an `ngDestroy()` callback and use it to call `NgxExtendedPdfViewerService.removePrintRange()`.\r\n\r\n### TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class PrintRangeComponent {\r\n  constructor(private printService: NgxExtendedPdfViewerService) {}\r\n\r\n  public setPrintRange(): void {\r\n    const range: PDFPrintRange = {\r\n      from: 1,\r\n      to: 10,\r\n      excluded: [2, 4, 6, 8],\r\n    };\r\n    this.printService.setPrintRange(range);\r\n  }\r\n}\r\n```\r\n\r\n## Override Browser Print\r\n\r\nSetting the attribute `replaceBrowserPrint` allows you to replace the browser default print functionality by printing the PDF file. No matter what your web page looks like, if `replaceBrowserPrint` is true, both the keys `CTRL+P` and the print menu of the browser print the PDF file. If you set `replaceBrowserPrint=\"false\"`, both `CTRL+P` and the print menu print the web page.\r\n\r\n**Note**: Starting with version 16.0.0, the `replaceBrowserPrint` is active by default.\r\n\r\n### HTML\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/BootsFaces_Deep_Dive_1.0.pdf'\"\r\n  zoom=\"50%\"\r\n  [replaceBrowserPrint]=\"true\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## Auto Rotation\r\n\r\nBy default, the PDF viewer rotates landscape pages when printing. You can switch this off by setting `enablePrintAutoRotate` to `false`. This is useful if you want to print a PDF file with a mix of portrait and landscape pages, and you want to keep the orientation of the pages as they are in the PDF file.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"src\"\r\n  [enablePrintAutoRotate]=\"false\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## Print Resolution\r\n\r\nThe attribute `printResolution` specifies the print resolution, with a default value of 150 dpi. If the specified resolution exceeds the browser's capabilities, it is adjusted downward, including a 5% margin for safety.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/BootsFaces_Deep_Dive_1.0.pdf'\"\r\n  [printResolution]=\"300\">\r\n</ngx-extended-pdf-viewer>\r\n```"
  },
  {
    "title": "Range Requests",
    "route": "/configuration/range-requests/",
    "content": "Sometimes PDF files are large, even huge. By default, the PDF loader doesn't load the entire PDF file. Instead, it loads it in chunks, and it uses streaming if the server allows it to do so. So the viewer can display the first page while it's still loading the other pages.\r\n\r\nMost of the time, you don't have to configure this feature (unless you want to switch it off). It just works. If it doesn't, check if your server supports range requests. If it does, the response headers have the attributes\r\n\r\n- \"Content-Length\"\r\n- \"Accept-Ranges\": \"bytes\",\r\n- \"Content-Encoding\"\r\n\r\n## CORS\r\n\r\nIf your PDF file is served by a different server than the Angular application, you must add the CORS headers to the response. Here's a simple demo server sending the correct headers:\r\n\r\n### TypeScript\r\n\r\n```typescript\r\nconst http = require(\"http\");\r\nconst port = process.env.PORT || 3000;\r\n\r\nconst { stat, createReadStream } = require(\"fs\");\r\nconst { promisify } = require(\"util\");\r\nconst { pipeline } = require(\"stream\");\r\nconst samplePDF = \"./demo.pdf\";\r\nconst fileInfo = promisify(stat);\r\n\r\nhttp\r\n  .createServer(async (req, res) => {\r\n\r\n    /** Calculate Size of file */\r\n    const { size } = await fileInfo(samplePDF);\r\n    const range = req.headers.range;\r\n    console.log(size)\r\n\r\n    /** Check for Range header */\r\n    if (range) {\r\n      /** Extracting Start and End value from Range Hea der */\r\n      let [start, end] = range.replace(/bytes=/, \"\").split(\"-\");\r\n      start = parseInt(start, 10);\r\n      end = end ? parseInt(end, 10) : size - 1;\r\n\r\n      if (!isNaN(start) && isNaN(end)) {\r\n        start = start;\r\n        end = size - 1;\r\n      }\r\n      if (isNaN(start) && !isNaN(end)) {\r\n        start = size - end;\r\n        end = size - 1;\r\n      }\r\n\r\n      // Handle unavailable range request\r\n      if (start >= size || end >= size) {\r\n        // Return the 416 Range Not Satisfiable.\r\n        res.writeHead(416, {\r\n          \"Content-Range\": `bytes */${size}`\r\n        });\r\n        return res.end();\r\n      }\r\n\r\n      /** Sending Partial Content With HTTP Code 206 */\r\n      res.writeHead(206, {\r\n        \"Content-Range\": `bytes ${start}-${end}/${size}`,\r\n        \"Accept-Ranges\": \"bytes\",\r\n        \"Content-Length\": end - start + 1,\r\n        \"Content-Type\": \"application/psdf\",\r\n        \"Access-Control-Allow-Origin\": \"http://localhost:4200\"\r\n      });\r\n\r\n      const readable = createReadStream(samplePDF, { start, end });\r\n      pipeline(readable, res, err => {\r\n        console.log(err);\r\n      });\r\n\r\n    } else {\r\n\r\n      res.writeHead(200, {\r\n        \"Access-Control-Expose-Headers\": \"Accept-Ranges\",\r\n        \"Access-Control-Allow-Headers\": \"Accept-Ranges,range\",\r\n        \"Accept-Ranges\": \"bytes\",\r\n        \"Content-Length\": size,\r\n        \"Content-Type\": \"application/pdf\",\r\n        \"Access-Control-Allow-Origin\": \"http://localhost:4200\"\r\n      });\r\n\r\n      if (req.method === \"GET\") {\r\n          const readable = createReadStream(samplePDF);\r\n          pipeline(readable, res, err => {\r\n            console.log(err);\r\n          });\t   \r\n      } else {\r\n        res.end();\r\n      }\r\n\r\n    }\r\n  })\r\n  .listen(port, () => console.log(\"Running on 3000 port\"));\r\n```\r\n\r\nKudos go to Chetan Patil who helped me figure this out.\r\n\r\nIf you want to dig deeper: Vishal Patel has written an [article on range requests](https://medium.com/@vishal1909/how-to-handle-partial-content-in-node-js-8b0a5aea216) and how to implement them in a simple node.js server.\r\n\r\n## Disable Range Request and Lazy Loading\r\n\r\nThe [default options](/basics/default-options) disableStream and disableAutoFetch allow you to switch off the feature. In most cases, this means it takes longer until the PDF file is shown, so use this option only as a last resort.\r\n\r\n**Caveat**: When I tried this, I didn't manage to disable range request. Chances are the feature is broken."
  },
  {
    "title": "Reading Metadata",
    "route": "/developer-experience/reading-metadata/",
    "content": "Once the PDF file has been loaded, you can extract quite a some metadata from it. You can get these infos after receiving the `(pagesLoaded)` event.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer \r\n  src=\"/assets/pdfs/The Public Domain - Enclosing the Commons of the Mind.pdf\" \r\n  [height]=\"'90vh'\" \r\n  (pagesLoaded)=\"onPagesLoaded()\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false, ...})\r\nexport class FileInfoComponent {\r\n  private notificationService = inject(PDFNotificationService);\r\n  private PDFViewerApplication = computed(() => this.notificationService.onPDFJSInitSignal());\r\n  \r\n  fileInfo: PdfDocumentInfo;\r\n\r\n  async onPagesLoaded() {\r\n    if (this.PDFViewerApplication()) {\r\n      const propertiesExtractor = new PdfDocumentPropertiesExtractor();\r\n      this.fileInfo = await propertiesExtractor.getDocumentProperties(this.PDFViewerApplication());\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Note**: At the moment the return type of `getDocumentProperties` is any. Behind the scenes it still builds an object of type `PdfDocumentInfo`.\r\n\r\n**Note**: If you expect to frequently read out the document properties, you can also instantiate the `PdfDocumentPropertiesExtractor` once and reuse it."
  },
  {
    "title": "Responsive Design",
    "route": "/customization/responsive-design/",
    "content": "The PDF viewer uses responsive design to display nicely on devices of all sizes. On large screens, the toolbar shows many buttons. On smaller screens, some of these buttons are shifted to the secondary menu. A few actions are only available in the secondary menu: the scroll mode, the spread modes, and the document properties. In a future version, I might add toolbar icons for these icons, so the corresponding attributes are also called `showXXXButton`, ignoring the fact that currently, these actions are currently only available in the secondary menu.\r\n\r\nI've breakpoints to the buttons to show as many buttons as possible on any screen. However, if you don't need every button, you've got more available screen estate. So you can override my choice of breakpoint by setting, for example, `showXXXButton=\"xs\"`. `xs` means the button shows if the PDF viewer is at least 490 pixel wide. `sm` means the button is visible if the PDF viewer is at least 560 pixels wide, and so on until `xxl`, which hides buttons if the PDF viewer is less than 830 pixels wide.\r\n\r\nNote that these width don't refer to the width of the screen. That's a difference to the definition of reponsive breakpoints in Tailwind, Bootstrap or Material Design. The PDF viewer frequently is smaller than the screen, so I went the extra mile to define breakpoints relative to the component width.\r\n\r\nYou can modify the breakpoints themselves if my default selection of 490, 560, 610, 660, 740, and 830 doesn't match your requirements. To do so, set the static attributes of the class `PdfBreakpoints`. You can experiment with these settings on the third tab of this demo.\r\n\r\nThe PDF viewer hides rarely used buttons on small screens, pushing them to the secondary menu. However, if you're showing only a subset of the buttons, the default are an ill match. So you can tweak this to fit your needs.\r\nSetting `showXXXButton=\"xs\"` means it's visible on very small screens, `showXXXButton=\"sm\"` means it's shown on small but hidden on tiny screens, and so on.\r\n\r\n## Custom Breakpoints \r\n\r\nYou can fine-tune when a breakpoint triggers. You have to resize the window after modifying the numbers to see the effect. There's no automatic update.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/pdf-sample.pdf'\"\r\n  [height]=\"'auto'\"\r\n  [showSidebarButton]=\"showSidebarButton\"\r\n  [showFindButton]=\"showFindButton\"\r\n  [showPagingButtons]=\"showPagingButtons\"\r\n  [showZoomButtons]=\"showZoomButtons\"\r\n  [showPresentationModeButton]=\"showPresentationModeButton\"\r\n  [showOpenFileButton]=\"showOpenFileButton\"\r\n  [showPrintButton]=\"showPrintButton\"\r\n  [showDownloadButton]=\"showDownloadButton\"\r\n  [showSecondaryToolbarButton]=\"showSecondaryToolbarButton\"\r\n  [showRotateButton]=\"showRotateButton\"\r\n  [showHandToolButton]=\"showHandToolButton\"\r\n  [showScrollingButtons]=\"showScrollingButton\"\r\n  [showSpreadButton]=\"showSpreadButton\"\r\n  [showPropertiesButton]=\"showPropertiesButton\"\r\n  height=\"250px\" zoom=\"25%\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({ ... })\r\nexport class CustomBreakpointsComponent {\r\n  constructor() {\r\n    // these are the default values\r\n    PdfBreakpoints.xs = 490; // unit: pixels\r\n    PdfBreakpoints.sm = 560;\r\n    PdfBreakpoints.md = 610;\r\n    PdfBreakpoints.lg = 660;\r\n    PdfBreakpoints.xl = 740;\r\n    PdfBreakpoints.xxl = 830;\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Scrolling Api",
    "route": "/developer-experience/scrolling-api/",
    "content": "The recommended approaches to scrolling are using `[page]` and `[namedDest]` (see [Navigation API Page](./developer-experience/navigation-api)). If you want to scroll within a page, there's a third option. `NgxExtendedPdfViewerService` offers a programmatic API:\r\n\r\n- `scrollPageIntoView(42)` is equivalent to [page]=\"42\".\r\n- `scrollPageIntoView(42, {top: '100%'})` scrolls to the bottom of page 42.\r\n- `scrollPageIntoView(42, {top: '50%'})` scrolls to the middle of page 42.\r\n- `scrollPageIntoView(42, {top: 500 })` scrolls to page 42, and then 500 pixels down.\r\n- `scrollPageIntoView(42, {left: '100%' })` scrolls to the right hand side of the page.\r\n\r\nNote that numerical values refer to pixels, so which part of the page become visible depends on the zoom level. Better use percentages.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'./assets/pdfs/The Public Domain - Enclosing the Commons of the Mind.pdf'\"\r\n  [zoom]=\"zoom\"\r\n  [height]=\"'auto'\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class ScrollingComponent {\r\n  constructor(private pdfService: NgxExtendedPdfViewerService) { }\r\n\r\n  public scroll(pageNumber: number, top: number | string): void {\r\n    this.pdfService.scrollPageIntoView(pageNumber, {top});\r\n  }\r\n}\r\n```\r\n\r\n## Edge Cases\r\n\r\nThe `left` parameter can be confusing, especially if your PDF document features bot landscape and portrait pages. In theory, the `left` parameter causes the page to scroll to the left by a given percentage. However, that's not always possible, because the horizontal scrollbar doesn't allow for arbitrary scrolling. In particular, 100% would indicate the page scrolls out of the visible area, but the scrollbar doesn't allow that."
  },
  {
    "title": "Server Side Rendering",
    "route": "/developer-experience/server-side-rendering/",
    "content": "Starting with version 16.2.14, ngx-extended-pdf-viewer supports server-side rendering out-of-the-box.\r\n\r\nSince version 21.3.4, the showcase uses static site generation (SSG). That doesn't mean the PDF files are generated on the server, but it means you can use ngx-extended-pdf-viewer in a server-side rendered Angular application. If there's a bug, it'll probably show up in the showcase, allowing me to detect and fix it."
  },
  {
    "title": "Showcase",
    "route": "/contributing/showcase/",
    "content": "# Contributing to the Showcase-Page\r\n\r\nFound a bug, typo or got any ideas for improvement for this Showcase? Every help is welcome! On this page you will find a guide on how to contribute.\r\n\r\n## Prerequisites\r\n\r\nTo get the repository working, you have to first complete the setup on the [PDF Viewer Contribution Page](./contributing/pdf-viewer).\r\n\r\n## Setup local environment\r\n\r\n1. Build the ngx-extended-pdf-viewer\r\n   1. ``npm run build``\r\n   2. This is necessary as the showcase depends on it\r\n2. Build the schematics\r\n   1. ``npm run build-schematics``\r\n3. Done.\r\n\r\nNow you can serve the showcase by running ``npm run serve:showcase``.\r\n\r\n## File Structure\r\n\r\nWithin _showcase/src/app_ you find multiple subfolders. Here is what they are meant for.\r\n\r\n- _core_: Contains components, directives, service, etc. that are either only used once in the entire app (e.g.: `layout.component.ts`) or that are used by such (e.g.: `block-on-open-sidebar.directive.ts`)\r\n- _pages_: Contains all the documentation pages. The structure is representative of the menu structure. See also [Building the menu](#Building the menu). The pages are organized by topics.\r\n- _shared_: Contains components, directives, service, etc. that are shared between multiple places (e.g.: `markdown-content.component.ts`)\r\n\r\n\r\n## Building the menu\r\n\r\nTo avoid manually managing all aspects of the menu, it is build automatically based on the `*.routes.ts` files.\r\n\r\n`app.routes.ts` is the entry point for the routes and essentially defines the order in which the page topics (About,Basics, etc.) are appearing. What matters is the order in which they get spread into the app routes.\r\n\r\n**Example**\r\n\r\n```ts\r\nexport const routes: Routes = [\r\n  {\r\n    path: '',\r\n    pathMatch: 'full',\r\n    redirectTo: 'about/introduction',\r\n  },\r\n  ...aboutRoutes,\r\n  ...basicsRoutes,\r\n  ...contributingRoutes,\r\n  ...configurationRoutes,\r\n  ...viewingRoutes,\r\n  ...findingRoutes,\r\n  ...customizationRoutes,\r\n  ...formsRoutes,\r\n  ...printingRoutes,\r\n  ...securityRoutes,\r\n  ...exportingRoutes,\r\n  ...developerExperienceRoutes,\r\n];\r\n\r\n```\r\n### Topic Route Files\r\n\r\nEach of the route files follow the same structure. They are placed in the top level of their topic folders. That means the `basics.routes.ts` is located under `showcase/src/app/basics` and the one for printing under `showcase/src/app/printing`.\r\n\r\nAll route files only define one routes array with one top-level route. The path of this route must be the same as the topic. For example the `basics.routes.ts` has the path 'basics'. This route also always is a route group, which means it does not load any components and adds `RouteGroupData`.\r\n\r\n#### Route Groups\r\n\r\nA route group does not load any component and only has children. For its data property it adds an object with a `key` (lowercase) and a `name` property (readable string). For type safety we add `<RouteGroupData>` in front of the object.\r\n\r\n**Example**\r\n```ts\r\n{\r\n  path: 'basics',\r\n    data: <RouteGroupData>{\r\n    key: 'basics', // defines key for tracking\r\n    name: 'Basics', // appears in the menu \r\n  },\r\n    children: [\r\n      //...\r\n  ],\r\n},\r\n```\r\n\r\n#### Route Targets\r\n\r\nA route target loads a component and cannot have children. For its data property it adds an object with a `pageTitle` property. This property is only used as the main title (`<h1>`) for pages that use the `content-page.component`. All other pages must define their own main title. For type safety we add `<RouteData>` in front of the data object.\r\n\r\n**Example**\r\n```ts\r\n{\r\n  path: 'getting-started',\r\n    component: GettingStartedPageComponent,\r\n    data: <RouteData>{\r\n    pageTitle: 'Getting Started', // main title of the page\r\n  },\r\n},\r\n```\r\n#### Putting it all together\r\n\r\nThe `navigation-config.ts` under _showcase/src/app/core/layout/sidenav_ puts everything together. If you are interested in how that works, this is the place to go. The resulting navigation config then gets used normally in the sidenav component.\r\n\r\n## Displaying a documentation page\r\n\r\nBesides a few special pages (like this one), all pages use the same layout. This is defined in the `content-page.component` under _showcase/src/app/shared/content-page_. By doing so we can ensure that changes are reflected on all pages equally.\r\n\r\nAll documentation pages use a tabbed layout. Some may only have one tab, while some have more. That depends on the content. All pages (except the special ones) have at least a \"Documentation\" tab. Some have a \"Demo\" tab in addition.\r\n\r\n### Documentation Tab\r\n\r\nThe content of the documentation page is coming from its `text.md` file. This file contains the actual documentation and, if applicable, code examples. It should not contain anything else (no controls, demos, etc.). However, it is allowed to use multiple markdown files if necessary. This could be done, if you need to share the same text on multiple pages. Generally we aim to keep the amount of files to manage low.\r\n\r\nThe big advantage of having the documentation in markdown is, that we can make changes easily without worrying about any HTML.\r\n\r\n**Example of minimal documentation page**\r\n```ts\r\n@Component({\r\n  selector: 'pvs-getting-started-page',\r\n  standalone: true,\r\n  imports: [ContentPageComponent, MarkdownContentComponent],\r\n  template: `<pvs-content-page>\r\n    <pvs-markdown src=\"/assets/pages/basics/getting-started/text.md\" />\r\n  </pvs-content-page>`,\r\n})\r\nexport class GettingStartedPageComponent {}\r\n```\r\n\r\n**Note**: All other layouting task are handled by the content page component.\r\n\r\n### Demo Tab\r\n\r\nA lot of documentation comes with an interactive demo. This demo is always placed in a separate tab, to keep everything organized and consistent.\r\n\r\nThe demo is always placed in an `ng-template` and in a `split-view.component`. The controls for the demo are on the left, the PDF Viewer on the right.\r\n\r\nThe PDF Viewer always need the following three directives applied (SHOWCASE ONLY):\r\n- `pvsSetMinifiedLibraryUsage`\r\n- `pvsSetDefaultViewerHeight`\r\n- `pvsSetDefaultZoomLevel`\r\n\r\nthose directives ensure that we can set default values across the page, without needing to update every single page.\r\n\r\nThere is one exception though: If your demo requires a specific height or zoom level, you can skip those directives. The `pvsSetMinifiedLibraryUsage` must never be skipped.\r\n\r\n**Example of documentation page with a demo**\r\n```ts\r\n@Component({\r\n  selector: 'pvs-blobs-page',\r\n  standalone: true,\r\n  imports: [\r\n    ContentPageComponent,\r\n    MarkdownContentComponent,\r\n    NgxExtendedPdfViewerModule,\r\n    SplitViewComponent,\r\n    SetMinifiedLibraryUsageDirective,\r\n    ReactiveFormsModule,\r\n    FormsModule,\r\n    ButtonDirective,\r\n    SetDefaultViewerHeightDirective,\r\n    SetDefaultZoomLevelDirective,\r\n  ],\r\n  template: `<pvs-content-page [demoTemplate]=\"demo\">\r\n    <pvs-markdown src=\"/assets/pages/basics/file-sources/blobs/text.md\" />\r\n    <pvs-markdown src=\"/assets/pages/basics/file-sources/shared.md\" />\r\n    <ng-template #demo>\r\n      <pvs-split-view>\r\n        \r\n        // Demo Controls go here\r\n        \r\n        <ngx-extended-pdf-viewer\r\n          slot=\"end\"\r\n          [src]=\"src\"\r\n          [textLayer]=\"true\"\r\n          [showPresentationModeButton]=\"true\"\r\n          pvsSetMinifiedLibraryUsage\r\n          pvsSetDefaultViewerHeight\r\n          pvsSetDefaultZoomLevel\r\n        />\r\n      </pvs-split-view>\r\n    </ng-template>\r\n  </pvs-content-page>`,\r\n})\r\nexport class BLOBsPageComponent {\r\n  // Demo code goes here\r\n}\r\n\r\n```\r\n\r\n**Note**: When adding inputs, radio buttons, etc. please use the same structure and CSS classes as the other pages. This ensures a consistent look.\r\n\r\n\r\n## Adding a new page\r\n\r\nNow that you know the anatomy of a documentation page, let's talk about how to actually add a new page.\r\n\r\nTo make this easier we added a schematic to handle pretty much everything for you. So you do not need to remember how to set everything up. \r\n\r\nTo run this schematic, first ensure you have built them. If you followed the setup guide above, you should be good to go. Otherwise, run `npm run build-schematics`.\r\n\r\nWhen the schematics are build, you can run `npm run add-documentation-page`. This schematic will prompt you for some information. All prompts have descriptions.\r\n\r\n### Limitations\r\n\r\nThis schematic is not able to create a nested documentation page, like the file source pages. If you need to that, first create the sub-menu group, if it doesn't already exist. Then run the schematic with the actual target path. Once the schematic is done, manually move the newly created route to its actual parent. Be sure to update the path to the `text.md` file, in the new component, too.\r\n\r\n## Adding a new top level menu group\r\n\r\nSince this should not be a common use case, there is no schematic for this. Here are the steps to manually create a new group.\r\n\r\n1. Under `showcase/src/app/pages` create a new folder with the name of the menu group (e.g.: new-stuff)\r\n2. Create a new routes file in your new folder (e.g.: `new-stuff.routes.ts`) and paste the template from below. Fill in the missing info and ensure it follows the convention mentioned above.\r\n3. Add the new routes array to `app.routes.ts` with the spread operator. Place it where it makes most sense. (e.g.: `...newStuffRoutes`)\r\n\r\nBe aware that the new group will only show once it actually has children.\r\n\r\n**Template**\r\nReplace \"new-stuff\" with the name of the new menu group\r\n```ts\r\nimport { Route } from '@angular/router';\r\nimport { RouteGroupData } from '../../shared/types/route-data.types';\r\n\r\nexport const newStuffRoutes: Route[] = [\r\n  {\r\n    path: 'new-stuff',\r\n    data: <RouteGroupData>{\r\n      name: 'New Stuff',\r\n      key: 'new-stuff',\r\n    },\r\n    children: [\r\n    ],\r\n  },\r\n];\r\n\r\n```\r\n\r\n## Styling\r\n\r\nFor styling we are using [Tailwind](https://tailwindcss.com). Some extensions and configurations were made for this showcase, so be sure to familiarize yourself with those.\r\n\r\nYou can find the _styles.css_ under _showcase/src_ and the _tailwind.config.js_ in the repository root.\r\n\r\n## UI Libraries\r\n\r\nWe are not using any UI Library for this showcase.\r\n\r\n## General Tips\r\n\r\nIf you are unsure on how to approach something, look at the already existing code. If nothing covers your use case, either ask in advance or make reasonable assumptions."
  },
  {
    "title": "Sidebar",
    "route": "/customization/sidebar/",
    "content": "You can customize both the sidebar. The only disadvantage is you have to set the `top` position yourself. If you're offering an optional mobile-friendly large toolbar, the `top` position of custom sidebars is not adjusted automatically.\r\n\r\nThe attribute `[(sidebarVisible)]` supports two-way binding. It's updated when the user opens or hide the sidebar.\r\n\r\n### HTML\r\n\r\n#### With Toolbar\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n    #pdfViewer\r\n    [src]=\"'/assets/pdfs/stluciadance.com.pdf'\"\r\n    [customSidebar]=\"theme==='fancy' ? fancySidebar: theme === 'without'? withoutSidebar: null\"\r\n    [(sidebarVisible)]=\"sidebarOpen\"\r\n    [textLayer]=\"true\"\r\n    [showHandToolButton]=\"true\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n#### No Sidebar\r\n\r\n```html\r\n<ng-template #withoutSidebar>\r\n  <div id=\"sidebarContainer\" style=\"top:-1px\">\r\n    <pdf-sidebar-content></pdf-sidebar-content>\r\n    <div id=\"sidebarResizer\" class=\"hidden\"></div>\r\n  </div>\r\n</ng-template>\r\n```\r\n\r\n#### Fancy Sidebar\r\n\r\n```html\r\n<ng-template #fancySidebar>\r\n  <div id=\"sidebarContainer\" style=\"top:31px;background-color:goldenrod\">\r\n    <div id=\"additionalSidebarContainer\">\r\n      <div id=\"toolbarSidebar\">\r\n        <div id=\"outlineOptionsContainer\" class=\"splitToolbarButton toggled\">\r\n          <button style=\"background-color: red; height:100%;width: 34%;border:0;margin:0;padding:0\" \r\n            type=\"button\" id=\"viewThumbnail\" \r\n            class=\"toolbarButton\" \r\n            data-l10n-id=\"thumbs\">\r\n            <span data-l10n-id=\"thumbs_label\">Thumbnails</span>\r\n          </button>\r\n          <button\r\n            style=\"background-color: green; height:100%;width: 35%;border:0;margin:0;padding:0\"\r\n            type=\"button\"\r\n            id=\"viewOutline\"\r\n            class=\"toolbarButton\"\r\n            data-l10n-id=\"document_outline\">\r\n            <span data-l10n-id=\"document_outline_label\">Document Outline</span>\r\n          </button>\r\n          <button\r\n            style=\"background-color: blue; height:100%;width: 34%;border:0;margin:0;padding:0\"\r\n            type=\"button\" \r\n            id=\"viewAttachments\" \r\n            class=\"toolbarButton\" \r\n            data-l10n-id=\"attachments\">\r\n            <span data-l10n-id=\"attachments_label\">Attachments</span>\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <pdf-sidebar-content></pdf-sidebar-content>\r\n    <div id=\"sidebarResizer\" class=\"hidden\"></div>\r\n  </div>\r\n</ng-template>\r\n\r\n```"
  },
  {
    "title": "Simple",
    "route": "/basics/simple/",
    "content": "Open a terminal and enter this command at your project's root folder:\r\n\r\n```cmd\r\nng add ngx-extended-pdf-viewer\r\n```\r\n\r\nThis configures your project, adds an example component and an example PDF file, so you just need to add the new `<add-example-pdf-viewer>` tag to one of your `*.html` files.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n   [src]=\"'/assets/pdfs/The Public Domain - Enclosing the Commons of the Mind.pdf'\"\r\n   [height]=\"'auto'\" <!-- you can also use %, px and vh, or omit the attribute altogether -->\r\n   [textLayer]=\"true\" <!-- enable the find button -->\r\n   [showHandToolButton]=\"true\" <!-- enable text selection -->\r\n   [filenameForDownload]=\"'Public Domain.pdf'\"> <!-- optional - define the filename if the user downloads the PDF -->\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## Basic Parameters\r\n\r\nThis demo shows the default viewer. The default configuration is pretty straightforward, as you can see on the right-hand side.\r\n\r\nIf you've set up the PDF viewer, but are missing the find dialog and the text selection: that's a performance optimization. Activate the `[textLayer]` to enable these two features.\r\n\r\nThe height attribute can often be omitted, too. The showcase only needs it because its layout framework, Angular Material, sets the height of the PDF viewer to zero pixels by default.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n   [src]=\"'/assets/pdfs/The Public Domain - Enclosing the Commons of the Mind.pdf'\"\r\n   [textLayer]=\"true\" <!-- enable the find button -->\r\n   [showHandToolButton]=\"true\" <!-- enable text selection -->\r\n   [showPresentationModeButton]=\"true\"\r\n   [(page)]=\"page\"\r\n   [(pageLabel)]=\"pageLabel\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\n @Component({\r\n  selector: 'app-simple',\r\n  templateUrl: './simple.component.html',\r\n  styleUrls: ['./simple.component.css']\r\n})\r\nexport class SimpleComponent {\r\n  public page = 5;\r\n\r\n  public pageLabel: string;\r\n}\r\n```\r\n\r\n## Page and Page Label\r\n\r\nThe page is the number page number. It always starts with 1.\r\n\r\nThe page label is the page number assigned by the author of the PDF document. For example, the document below uses roman numbers for the table of contents and arabic numbers for the main body.\r\n\r\nIf you try to use both `[(page)]` and `[(pageLabel)]` with two-way binding, you'll run into `ExpressionChangedAfterItHasBeenCheckedErrors`. To prevent this, you'll want to adopt the `OnPush` change detection strategy.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/The Public Domain - Enclosing the Commons of the Mind.pdf'\"\r\n  [theme]=\"theme\"\r\n>\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### TypeScript\r\n\r\n```typescript\r\n @Component({ ... })\r\nexport class SimpleComponent {\r\n  public set theme(theme: 'dark' || 'light') {\r\n    // this demo stores the theme in the local storage \r\n    // because it take on reload only\r\n    localStorage.setItem('ngx-extended-pdf-viewer.theme', theme);\r\n    location = location; // force reload\r\n  }\r\n\r\n  public get theme(): 'dark' || 'light' {\r\n    return localStorage.getItem('ngx-extended-pdf-viewer.theme') || 'light';\r\n  }\r\n}\r\n```\r\n\r\n\r\n## Color Themes\r\n\r\nYou can choose between two predefined color themes, or you can provide your own custom color theme. Note that switching the themes doesn't work reliably without a full reload (i.e. hitting the F5 or CMD+R key). This demo reloads the page programmatically each time you change the theme.\r\n\r\n## Height\r\n\r\nIf you omit the [height] attribute, the PDF viewer tries to use all the available vertical space. To make this work, make sure the surrounding container is large enough to contain the PDF viewer. By default, many CSS frameworks set the height of an empty container to zero pixels. You can use the height attribute to work around this limitation or to fine-tune the amount of screen estate you need."
  },
  {
    "title": "Text",
    "route": "/configuration/layers/text/",
    "content": "The text layer is an optional, invisible layer above the PDF document, which is rendered as an image. You need it to\r\n\r\n- mark and copy texts\r\n- find texts\r\n- and, to a limited extend and far from being perfect, to modify how texts are displayed.\r\n\r\nBy default, the text layer is switched off in order to render the document faster. The drawback is that both the find menu and the select tool are disabled until you activate the text layer."
  },
  {
    "title": "Text",
    "route": "/exporting/text/",
    "content": "You can extract text from the PDF file that's currently displayed.\r\n\r\nYou can get the text either as plain text or as text with metadata. The second option, `NgxExtendedPdfViewerService::getPageAsLines`, returns an array that tries to split the text into lines, along with the coordinates of the line and a flag indicating whether the line is written left-to-right or right-to-left.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n    [src]=\"'/assets/pdfs/blind-text-collection.pdf'\"\r\n    [textLayer]=\"true\" <!-- enable the find button -->\r\n    [showHandToolButton]=\"true\" <!-- enable text selection -->\r\n    [height]=\"'90vh'\"> <!-- by default, most CSS frameworks set the height to 0 -->\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n\r\npublic extractedText: string | undefined;\r\n\r\npublic extractedLines: Array<string> = [];\r\n\r\nconstructor(private pdfViewerService: NgxExtendedPdfViewerService) {}\r\n\r\npublic async exportAsText(): Promise<void> {\r\n  this.selectedTabIndex = 3;\r\n  this.extractedLines = [];\r\n  this.extractedText = await this.pdfViewerService.getPageAsText(1);\r\n}\r\n\r\npublic async exportAsLines(): Promise<void> {\r\n  const lines = await this.pdfViewerService.getPageAsLines(1);\r\n  this.extractedText = undefined;\r\n  this.extractedLines = lines.map(line => line.text);\r\n  console.log(lines);\r\n}\r\n```"
  },
  {
    "title": "Theming",
    "route": "/viewing/theming/",
    "content": "You can theme the PDF viewer and - to a limited extent - also how forms are displayed in a PDF files. However, most PDF documents define how the form is displayed. ngx-extended-pdf-viewer does not overwrite the CSS rules defined by the PDF author.\r\n\r\n`ngx-extended-pdf-viewer` ships with a light theme and a dark theme. Plus, you can define a custom theme.\r\n\r\nNote that there's no theming for forms. Theming only changes the appearance of the PDF viewer. It does not change the way PDF files are rendered.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"src\"\r\n  [theme]=\"theme\"\r\n  [backgroundColor]=\"backgroundColor\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\nexport class FormsComponent {\r\n  theme = 'light';\r\n}\r\n```"
  },
  {
    "title": "Thumbnails",
    "route": "/customization/thumbnails/",
    "content": "You can customize the thumbnails. To do so you need to define something that looks like an Angular template, but isn't an Angular template. It's not part of the Angular interpolation and lifecycle, so there are several restrictions. This demo shows over to circumvent them.\r\n\r\nIf you want to use CSS classes, set `encapsulation: ViewEncapsulation.None`.\r\n\r\nIn the HTML definition, you can use these variable PAGE_NUMBER.\r\n\r\nIf you need more fine-grained control, modify the thumbnail in an event listener of `(thumbnailDrawn)`. The demo uses this option to color the thumbnails differently and to add the diagonal text.\r\n\r\n## Call Angular Code\r\n\r\nIf you want to call Angular code from the template, implement `(thumbnailDrawn)` and use it to register the event listener. If you're not using ngZone, you need to call `ChangeDetectorRef.detectChanges()` or `ChangeDetectorRef.markForCheck()`.\r\n\r\nThe demo set the initial state of the radio buttons in `(thumbnailDrawn)`. It also adds an event listener to rotate the pages on double-click.\r\n\r\n\r\n## HTML\r\n\r\n### PDF Viewer\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n    [src]=\"'/assets/pdfs/stluciadance.com.pdf'\"\r\n    [customThumbnail]=\"radiobuttonThumbnail\"\r\n    (pageChange)=\"onPageChange($event)\"\r\n    (thumbnailDrawn)=\"onThumbnailDrawn($event)\"\r\n    [sidebarVisible]=\"true\"\r\n    [activeSidebarView]=\"1\">\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n### Thumbnail\r\n\r\n```html\r\n<ng-template #radiobuttonThumbnail>\r\n  <a class=\"pdf-viewer-template\">\r\n    <div class=\"thumbnail\" data-page-number=\"PAGE_NUMBER\" style=\"border: none\">\r\n      <input id=\"thumbnail-cbx-PAGE_NUMBER\" data-page-number=\"PAGE_NUMBER\" class=\"thumbnail-radiobutton\" type=\"radio\" style=\"top: 100px; right: 25px; position: relative; transform: scale(1.5)\" />\r\n      <div class=\"thumbnail-text\"></div>\r\n      <div class=\"image-container\" style=\"width: var(--thumbnail-width); height: var(--thumbnail-height)\">\r\n        <img class=\"thumbnailImage\" />\r\n      </div>\r\n      <div style=\"margin-top: -30px;margin-left: auto;margin-right: auto;text-align: center;width: 25px;height: 25px;border-radius: 50%;background-color: blue;\r\n          color: white;line-height: 25px;\">\r\n        #PAGE_NUMBER\r\n      </div>\r\n    </div>\r\n  </a>\r\n</ng-template>\r\n```\r\n\r\n## TypeScript\r\n\r\n### Thumbnail Drawn\r\n\r\n```typescript\r\npublic onThumbnailDrawn(thumbnailEvent: PdfThumbnailDrawnEvent): void {\r\n  const thumbnail = thumbnailEvent.thumbnail;\r\n\r\n  if (page === this.PDFViewerApplication.page) {\r\n    const radiobutton = thumbnail.querySelector('input.thumbnail-radiobutton');\r\n    if (radiobutton instanceof HTMLInputElement) {\r\n      radiobutton.checked = true;\r\n    }\r\n  }\r\n\r\n  const overlay = thumbnail.querySelector('.image-container') as HTMLElement;\r\n  let type: string;\r\n  if (page <= 2) {\r\n    overlay.style.backgroundColor = '#0000FF40';\r\n    type = 'title page';\r\n  } else if (page === 3 || page === 4) {\r\n    overlay.style.backgroundColor = '#00FF0040';\r\n    type = 'table of contents';\r\n  } else {\r\n    overlay.style.backgroundColor = '#FF000040';\r\n    type = 'ready for review';\r\n  }\r\n  const textNode = thumbnail.querySelector('.thumbnail-text') as HTMLDivElement;\r\n  if (textNode) {\r\n    textNode.innerText = type;\r\n  }\r\n}\r\n```\r\n\r\n#### Calling Angular Code\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false, \r\n  selector: 'app-custom-thumbnails',\r\n  templateUrl: './custom-thumbnails.component.html',\r\n  styleUrls: ['./custom-thumbnails.component.css'],\r\n  encapsulation: ViewEncapsulation.None,\r\n})\r\nexport class CustomThumbnailsComponent implements OnInit, OnDestroy {\r\n  constructor() {}\r\n\r\n  public onThumbnailDrawn(thumbnailEvent: PdfThumbnailDrawnEvent): void {\r\n    const overlay = thumbnail.querySelector('.image-container') as HTMLElement;\r\n     overlay.ondblclick = () => {\r\n      this.rotation = this.rotation ? 0 : 180;\r\n    };\r\n  }\r\n\r\n}\r\n```"
  },
  {
    "title": "Toolbar",
    "route": "/customization/toolbar/",
    "content": "`ngx-extended-pdf-viewer` allows you to define your own custom toolbar, menu, and it even allows you to create your own sidebar and your own thumbnails.\r\n\r\n### HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  #pdfViewer\r\n  [customToolbar]=\"additionalButtons\"\r\n  [src]=\"'/assets/pdfs/dachstein.pdf'\"\r\n</ngx-extended-pdf-viewer>\r\n\r\n<ng-template #additionalButtons>\r\n  <div id=\"toolbarViewer\" style=\"background-color:darkblue\">\r\n    <div id=\"toolbarViewerLeft\">\r\n      <pdf-toggle-sidebar></pdf-toggle-sidebar>\r\n      <div class=\"toolbarButtonSpacer\"></div>\r\n      <pdf-paging-area></pdf-paging-area>\r\n    </div>\r\n    <pdf-zoom-toolbar ></pdf-zoom-toolbar> <!-- toolbar viewer middle -->\r\n    <div id=\"toolbarViewerRight\">\r\n      <pdf-open-file></pdf-open-file>\r\n      <pdf-presentation-mode></pdf-presentation-mode>\r\n      <pdf-print></pdf-print>\r\n      <app-open-in-new-tab></app-open-in-new-tab>\r\n      <pdf-download></pdf-download>\r\n      <div class=\"verticalToolbarSeparator hiddenSmallView\"></div>\r\n      <pdf-toggle-secondary-toolbar></pdf-toggle-secondary-toolbar>\r\n    </div>\r\n  </div>\r\n</ng-template>\r\n```\r\n#### Additional Component\r\n\r\n```html\r\n<pdf-shy-button\r\n  [cssClass]=\"'lg' | responsiveCSSClass\"\r\n  class=\"newTab\"\r\n  title=\"open PDF file in a new tab\"\r\n  primaryToolbarId=\"openInNewTab\"\r\n  l10nId=\"infinite_scroll\"\r\n  [toggled]=\"hasBeenClicked\"\r\n  [action]=\"onClick\"\r\n  [order]=\"1\"\r\n  [closeOnClick]=\"true\"\r\n  image=\"<svg xmlns='http://www.w3.org/2000/svg' height='24' viewBox='0 0 24 24' width='24'>\r\n     <path fill='red' d='M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z'/>\r\n    </svg>\"\r\n>\r\n</pdf-shy-button>\r\n```\r\n\r\n### TypeScript\r\n\r\nThe PDF viewer doesn't restart reliably when you change the theme. So this demo hides the PDF viewer before changing the theme.\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class CustomToolbarComponent {\r\n  public _theme = 'findbar';\r\n\r\n  public showPdfViewer = true;\r\n\r\n  public set theme(theme: string) {\r\n    if (this._theme !== theme) {\r\n      this.showPdfViewer = false;\r\n      this._theme = theme;\r\n      setTimeout(() => this.showPdfViewer = true, 100);\r\n    } else {\r\n      this._theme = theme;\r\n    }\r\n  }\r\n\r\n  public get theme(): string {\r\n    return this._theme;\r\n  }\r\n}\r\n```"
  },
  {
    "title": "Touch Gestures",
    "route": "/viewing/touch-gestures/",
    "content": "## Double Click\r\n\r\nThe double-tap (or double-click) gesture enlarges the PDF file. By default, the target zoom is `page-width`. You can define a different target zoom by setting `pdfDefaultOptions.doubleTapZoomFactor`. In this demo, that's 125%.\r\n\r\nThere are three additional settings:\r\n\r\n- `pdfDefaultOptions.doubleTapZoomsInHandMode`: Activates the double-tap gesture when the hand mode is active. True by default.\r\n- `pdfDefaultOptions.doubleTapZoomsInTextSelectionMode`: Activates the double-tap gesture when the select mode is active. False by default.\r\n- `pdfDefaultOptions.doubleTapResetsZoomOnSecondDoubleTap`: Allows you to reset the zoom on a second double-tap. False by default (but true in this demo).\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/demo.pdf'\"\r\n  [minZoom]=\"0.5\"\r\n  [maxZoom]=\"1.5\"\r\n>\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\nimport { pdfDefaultOptions } from 'ngx-extended-pdf-viewer';\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class MobileComponent {\r\n\r\n  public zoomLevels = ['auto', 'page-actual', 'page-fit', 'page-width',\r\n                       0.5, 0.67, 0.75, 0.82, 0.9, 1, 1.1, 1.15, \r\n                       1.25, 1.5];\r\n  \r\n  constructor() {\r\n    pdfDefaultOptions.doubleTapZoomFactor = \"125%\";\r\n  }                       \r\n}\r\n```"
  },
  {
    "title": "Troubleshooting",
    "route": "/about/troubleshooting/",
    "content": "### How to report issues and bugs\r\n\r\nIf there's any compatibility issue with an older version of Angular, please tell me on my [bugtracker](https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues).\r\n\r\nTalking about bugs and feature requests: I also listen to StackOverflow, but it may take some time until I pick up bug reports from StackOverflow.\r\n\r\n## Modals\r\nPutting an `<ngx-extended-pdf-viewer>` into a modal often causes timing problems. If the modal doesn't initialize the PDF viewer,\r\nadd a short timeout. The idea is to show the PDF viewer with a short delay, so the modal has enough time to render.\r\n\r\nIf the PDF viewer prints exceptions in the console log when closing the modal, you may want to call `ngOnDestroy()`\r\nmanually. <a href=\"/modal\">The demo on modals</a> demonstrates this approach.\r\n\r\n## Promise.allSettled is not a function\r\n\r\nPlease update the library `zone.js` to a current version. At the time of writing, that's 0.10.3. For some reason, the default setup of Angular locks `zone.js` to an old version. In most cases, the update shouldn't cause problems.\r\n\r\n## Running Angular in a context path or using a non-standard assets folder\r\nThe CMap files and the JavaScript files <code>pdf.min.js</code>, <code>viewer.min.js</code>, and <code>pdf.worker.min.js</code> are expected to be in the assets folder of your application.\r\nSometimes the path resolution fails. In this case, you'll need to set the default option <code>assetsFolder</code> to the appropriate value.\r\nMaybe you'll even have to modify the derived options <code>workerSrc</code> and <code>cMapUrl</code>.\r\n\r\nAnother workaround is to load the files <code>pdf.min.js</code> and <code>viewer.min.js</code> yourself. You just have to make sure that the files are loaded before ngx-extended-pdf-viewer is initialized. The drawback of this approach is that there's no automatic browser switch. ngx-extended-pdf-viewer detects the capabilities the user's browsers and selects either the slow-but-safe ECMAScript 5 version, or the faster default version that only runs on modern browsers.\r\n\r\nIn any case, you should not load the file <code>pdf.worker.min.js</code> yourself. Technically, that's possible, and the approach works well for small PDF files. But it ruins the performance of the PDF viewer. One of our <a href=\"https://www.obwb.ca/library/okanagan-basin-waterscape-poster/\">test PDF files (75 MB!)</a> shows almost immediately in the default configuration, but takes several minutes when your loading <code>pdf.worker.min.js</code> yourself. (The technical explanation is that loading the pdf worker file yourself disables the service worker).\r\n\r\n## I can't find the find button\r\n\r\nFirst of all, I have to apologize: For some reason, I've never managed to make the  intuitive. I hope I'll manage one day or another!\r\n\r\nThe PDF viewer uses two layers of information. The first layer is what you see. That's simply an image. The second layer is the text layer. You need it to select text, and without the text layer you can't find anything. The \"find\" function can only cope with text, not with images.\r\n\r\nTo activate the \"find\" button you need a PDF file that contains text. A surprising number of PDF files are just images. If you've got such a PDF file, there's no find button. The PDF viewer doesn't include an OCR reader.\r\n\r\nSecond, you have to activate the attribute `textlayer`:\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n     [textLayer]=\"true\"  <!-- necessary to activate the find button and the select tool -->\r\n     [showHandToolButton]=\"true\" <!-- displays the \"select tool\" and the \"hand tool\" buttons -->\r\n     [src]=\"'/assets/pdfs/blind-text-collection.pdf'\"\r\n     [height]=\"'90vh'\">\r\n  </ngx-extended-pdf-viewer>\r\n```\r\n\r\n## I can't select text\r\n\r\nThat's mostly the same as the trouble with the find button. Activate the text layer, set `[showHandToolButton]=\"true\"`, use a PDF file containing text, and you're good to go. That's an annoyingly long list of conditions. Sorry for that!\r\n\r\n## When I select or find text, the selection is slightly off\r\n\r\nThe text layer doesn't match the real positions of the text. It's a good approximation, but it's not perfect. More often than not, the selection is half a character off, sometimes even more. There's nothing you can do about it - except offering your help at the base project, <a target=\"#\" href=\"https://github.com/mozilla/pdf.js\">pdf.js</a>. The project support almost every language and every font of the world, so it's hard to get it right.\r\n\r\n## Why is the text layer deactivated by default?\r\n\r\nThe PDF viewer is a lot faster if it doesn't have to render the text layer. That's why you have to activate the text layer manually.\r\n\r\n## Problems with Internet Explorer 11\r\nThe library is intended to be used with IE11 - but every once in a while, a new incompatibility pops up. Bear with me. I don't use Windows to develop the library, so testing IE11 isn't that easy.\r\n\r\nThe latest error I've seen is caused by another library, zone.js. Version 0.11.1 of zone.js is incompatible with IE11. If I've got it correctly, this will be fixed with version 0.11.2. What I can tell for sure is downgrading to version 0.10.3 fixes the bug. More details <a target=\"#\" href=\"https://github.com/angular/angular/issues/38561\">in the GitHub ticket</a>.\r\n\r\n## iOS emulators; iOS 13 with ngx-extended-pdf-viewer 8.x\r\n\r\nThe base library, pdf.js, has begun to use advanced features of JavaScript with version 2.7. That corresponds with version 8.0 of ngx-extended-pdf-viewer. That's ok because pdf.js is the PDF viewer of Firefox - nothing less and nothing more - but it's a challenge for third-party library like ngx-extended-pdf-viewer. The solution is to use the ES5 version of pdf.js. ngx-extended-pdf-viewer tries to detect the features of your browser and to load the appropriate version of pdf.js.\r\n\r\nThere's a catch: starting with version 8.1.2, ngx-extended-pdf-viewer uses an algorithm that works fine on actual iPhones and iPads running on iOS 13.x, but if you're running the application in an emulator, it may report an unrecoverable error. Such as <a href=\"https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/657#issuecomment-783555261\">this error report shows</a>. If you run into such an error, test the code on a real device. Chances are it turns out to be a false positive.\r\n\r\nOh, and if you've got a better idea how to check compatibility, don't hesitate to <a href=\"https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues\">open a bug report</a>!\r\n\r\n## No PDF file shown - error message \"offsetParent not set - cannot scroll\" in the console\r\n\r\nThis error means that the PDF viewer is invisible at load time. For example, that happens frequently with modal windows. If there's a fade-in animation, there's a small time frame when the PDF viewer is still invisible. In this case, you need to add a small delay before initializing it.\r\n\r\nTwo solutions are sketched in the <a href=\"https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/489#issuecomment-703838087\">GitHub issues</a>:\r\n\r\n```typescript\r\nopenModal(modaltemplate: any): void {\r\n  modaltemplate.show();\r\n  setTimeout(() => this.stringSource = this.url, 50); // <<< added delay\r\n}\r\n```\r\n\r\nIf you're using Bootstrap, you can also use the event `(onshown)` like so:\r\n\r\n```html\r\n<div bsModal #pdfModal=\"bs-modal\" class=\"modal\" \r\n     (onShown)=\"onModalShown($event)\">\r\n```\r\n\r\n## Trouble with printing (aka: compatibility to Bootstrap and other CSS frameworks)\r\nProblems with printing are almost always problems of your CSS code. That doesn't necessarily mean you've done anything wrong.\r\nMost people run into this kind of trouble when using a CSS framework that hasn't been written with ngx-extended-pdf-viewer in mind.\r\nThat, in turn, is probably true for every CSS framework out there. The core library assumes there's no CSS framework at all.\r\nIt's the PDF viewer of Firefox, so that's a reasonable assumption.\r\n\r\n\r\nIf you wonder how CSS and printing are related: the thing is that the PDF viewer doesn't really print anything. It just hides the entire page using CSS and adds high-resolution images to the HTML document. After that, the PDF viewer simply calls the print function of your browser. Basically, it's printing the entire HTML page, including your Angular application. If everything works as intended, you don't notice because your Angular application is hidden.\r\n\r\nHowever, your custom CSS is still active. For example, if it reduces the font size, you end up with scaled-down pages in print.\r\n\r\nngx-extended-pdf-viewer covers several popular CSS frameworks (such as BootsFaces and Material Design), but it's still possible there's a conflict I haven't seen yet. If so, checking the `display` and `overflow` properties is a good starting point. Often adding this CSS snippet solves the problem:\r\n\r\n```css\r\n@media print {\r\n  #printContainer > div {\r\n    display: inline;\r\n    overflow-y: visible;\r\n  }\r\n}\r\n```\r\n## Empty pages when printing\r\n\r\nIf you find empty pages in your print, often adding these CSS rules to your global `styles.scss` helps:\r\n\r\n```css\r\n@media print {\r\n  #printContainer > .printedPage {\r\n    width: 99%;\r\n  }\r\n}\r\n```\r\n\r\n## Hunting down other printing issues\r\n\r\nYou can debug print issues yourself. I've written detailed instructions here: <a href=\"https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/1431#issuecomment-1162091452\">https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/1431#issuecomment-1162091452</a>. When starting the\r\ndebugging session, you'll probably want to compare the CSS rules of your project with the reference project. You can either use the Angular schmetics\r\nto create a fresh project within a few minutes (see <a href=\"https://pdfviewer.net/extended-pdf-viewer/getting-started\">https://pdfviewer.net/extended-pdf-viewer/getting-started</a>), or you can use the <a href=\"https://mozilla.github.io/pdf.js/web/viewer.html\">showcase of Mozilla's project</a>.\r\n\r\n\r\n### Possibly outdated hint: printing with Bootstrap\r\n\r\nAs far as I remember, I've managed to solve this bug for you. But if you're using an older version of ngx-extended-pdf-viewer, the bug might still hit you. Bootstrap interferes with the printing algorithm of `pdf.js`. Guard it with a media query to avoid unwanted effects, such as scaling the print to 65%. For example, if you're using SCSS and Bootstrap 4, remove the import of Bootstrap.min.css from the Angular.json file. Instead, import it by including Bootstrap by adding this line to the global `styles.scss` file:\r\n\r\n```css\r\n@media screen {\r\n  @import '../node_modules/bootstrap/scss/bootstrap';\r\n}\r\n```\r\nCaveat: this trick only works with the SCSS version of both `styles.scss` and `bootstrap.scss`. It doesn't work with simple CSS. If you're using pure CSS, you can use the solution suggested by <a href=\"https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/48#issuecomment-596629621\" target=\"#\">Austin Walker</a>:\r\n\r\n```css\r\n@media print {\r\n  body {\r\n    min-width: auto !important;\r\n  }\r\n}\r\n```\r\n\r\n### Dig deeper\r\n\r\nIf you need more information, have a look at these issues:\r\n* https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/148\r\n* https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/175\r\n* https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/143 \r\n\r\n\r\n## Localization\r\n\r\nIf the PDF viewer doesn't show in your native language (or the language you're configured with the `[language]` attribute), please check the network tab and the settings in the Angular.json file. You must copy the  folder `node_modules/ngx-extended-pdf-viewer/assets/locale` recursively to the folder `assets/locale`. If you only want to support a few language, you can reduce the size of the installation by omitting the other language files. However, that doesn't improve performance.\r\n\r\n## Multiple PDF viewers on the same page (e.g. tabs)\r\n\r\nUnfortunately, you can't use multiple instances of `<ngx-extended-pdf-viewer>` on the same page. You're restricted to a single PDF viewer. This also applies to hidden PDF viewers. If you're using tabs containing PDF files, make sure you hide the PDF viewer before showing the next tab. You'll also need a short delay before showing the new PDF viewer. It takes some time to remove every object from memory.\r\n## Other hints collected over time\r\n\r\n| Error message or description                                            | Solution                                                                                                                                                                                                                                                                                                                                   |\r\n|-------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| sticky toolbar (when scrolling, the pdf file appears above the toolbar) | This happens if you're using the z-index to position the `<ngx-extended-pdf-viewer>`. If you can't avoid to do so, add the global CSS rule `.body .toolbar { z-index: 0; }`. The PDF viewer works without the z-index of the toolbar. The only difference is that the shadow of the toolbar is hidden by the PDF document.                 |\r\n| Print also includes UI elements                                         | Usually, the entire screen is hidden automatically, but sometimes this fails, especially with widgets that are dynamically added, such as error messages, progress bars, and block UI overlays. Use media queries to hide the unwanted UI elements. For example, use something like `@media print { #modal-error-dialog: display none; }`. |\r\n\r\n# Hint referring to old versions of ngx-extended-pdf-viewer\r\n\r\nUsing the PDF viewer has become a lot simpler over time. However, if you're using a pre 2.0 version, or if you've got a non-standard configuration, these hints may be useful to you.\r\n\r\n## Loading the JS file in the wrong order\r\n\r\nHave a look at [this discussion](https://github.com/stephanrauh/ngx-extended-pdf-viewer/issues/20). Several developers observed it's a good idea to load the three pdf.js files before any other additional JavaScript file. Plus, they use each other, so they need to be defined in this order:\r\n\r\n```json\r\n\"scripts\": [\r\n  \"node_modules/ngx-extended-pdf-viewer/assets/pdf.js\",\r\n  \"node_modules/ngx-extended-pdf-viewer/assets/viewer.js\",\r\n  (put any additional JavaScript file here)\r\n]\r\n```\r\n\r\nThere's a third file - `node_modules/ngx-extended-pdf-viewer/assets/pdf.worker.js`. Earlier versions of these instructions told you to put add it in the `scripts` section, too, but that's wrong, as you'll see in the next paragraph.\r\n\r\n\r\n## Fake worker\r\nIf you see the message \"Setting up fake worker\", everything works fine, except you're wasting performance. To avoid that, make sure that the file `pdf.worker.js` (or `pdf.worker-es5.js` for developers supporting IE11) is *not* part of the `scripts` section of the `angular.json`.\r\n\r\nInstead, put the pdf.worker.js file into the assets folder. The path can be configured in the global constant `defaultOptions.workerSrc` (which, in turn, is defined in the file `default-options.ts`). By default, it's './assets/pdf.worker.js'. In other words, you need to add these lines to the `angular.json`:\r\n\r\n```json\r\n\"assets\": [\r\n   ...,\r\n   {\r\n      \"glob\": \"pdf.worker.js\", // or \"pdf.worker-es5.js\" to support IE11\r\n      \"input\": \"node_modules/ngx-extended-pdf-viewer/assets\",\r\n      \"output\": \"/assets/\"\r\n   }\r\n```\r\n\r\nIf you need IE11 support, you also need to configure the URL of the worker file:\r\n\r\n```typescript\r\nimport { defaultOptions } from 'ngx-extended-pdf-viewer';\r\n\r\n@Component(...)\r\nexport class PdfDisplayComponent {\r\nconstructor() {\r\n    defaultOptions.workerSrc = './assets/pdf.worker-es5.js';\r\n  }\r\n```\r\n\r\nIf everything works, the file is lazy-loaded when the PDF viewer opens, and you're rewarded with a non-blocking PDF viewer, even if your PDF file is huge.\r\n\r\n## set delayFirstView=\"1000\" (deprecated)\r\n\r\nThis workaround was needed in the early version of ngx-extended-pdf-viewer, before I understood how to initialize the library correctly. However, it may come in handy every once in a while. Sometimes the initialization of the pdf viewer takes some time, so the PDF file is opened too early. As a work-around, you can add a delay. Setting it to one second is usually a good compromise:\r\n\r\n```html\r\n<ngx-extended-pdf-viewer src=\"...\" [delayFirstView]=\"1000\"></ngx-extended-pdf-viewer>\r\n```\r\n\r\n## \"Failed to load module script: Expected a JavaScript module script but the server responds with a MIME type of \"text/plain\"\r\n\r\nUpdate your server configuration. Many servers don't recognize `*.mjs` files as JavaScript. To fix this, you have to configure the server so it sends the file with the proper MIME type (`text/javascript`). You also have to configure the new i18n files. They've got the file ending `.ftl` and need the MIME type `text/plain`.\r\n\r\nFor example, IIS requires this configuration:\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<configuration>\r\n\r\n  <system.webServer>\r\n  <staticContent>\r\n    <mimeMap fileExtension=\".mjs\" mimeType=\"text/javascript\" />\r\n    <mimeMap fileExtension=\".ftl\" mimeType=\"text/plain\" />\r\n  </staticContent>\r\n  </system.webServer>\r\n\r\n</configuration>\r\n```\r\n\r\nnginx requires this configuration:\r\n\r\n```nginx\r\nlocation / {\r\n    ...\r\n\r\n    location ~* \\.mjs$ {\r\n                # target only *.mjs files\r\n                # now we can safely override types since we are only\r\n                # targeting a single file extension.\r\n                types {\r\n                    text/javascript mjs;\r\n                }\r\n            }\r\n  }\r\n```\r\n\r\nAWS amplify requires this configuration in the `amplify.yaml` file:\r\n\r\n```yaml\r\ncustomHeaders:\r\n  - pattern: '*.mjs'\r\n    headers:\r\n      - key: 'Content-Type'\r\n        value: 'application/javascript'\r\n```"
  },
  {
    "title": "Unverified Signatures",
    "route": "/developer-experience/unverified-signatures/",
    "content": "**Using this feature is dangerous!**\r\n\r\nPDF forms can bear a digital signature. Such a signature confirms that the PDF that it's been created by the author (and not someone else).\r\n\r\nHowever, ngx-extended-pdf-viewer **does not verify the validity** of the signature. The signature is displayed without any hint it's faulty. So use this feature carefully! Do not show the signature unless you're 100% sure it's valid. Otherwise, users may draw wrong conclusions.\r\n\r\nTo activate signatures, you must set the attribute `showUnverifiedSignatures`.\r\n\r\n## HTML\r\n\r\n```html\r\n <ngx-extended-pdf-viewer\r\n    [src]=\"'/assets/pdfs/unverified-signature.pdf'\"\r\n    [height]=\"'90vh'\"\r\n    [showUnverifiedSignatures]=\"true\">\r\n  </ngx-extended-pdf-viewer>\r\n```"
  },
  {
    "title": "Url",
    "route": "/basics/file-sources/url/",
    "content": "To display a PDF from an url just pass it to the `[src]` attribute.\r\n\r\n### Html\r\n\r\n```html\r\n<ngx-extended-pdf-viewer [(src)]=\"src\" [height]=\"'90vh'\"> </ngx-extended-pdf-viewer>\r\n```\r\n\r\n### Typescript\r\n\r\n```ts\r\n@Component({ ... })\r\nexport class FileSourcesComponent {\r\n  public src = 'assets/pdfs/pdf-sample.pdf';\r\n  public url = new URL('http://pdfviewer.net/assets/pdfs/GraalVM.pdf');\r\n}\r\n```"
  },
  {
    "title": "Xfa Forms",
    "route": "/forms/xfa-forms/",
    "content": "`ngx-extended-pdf-viewer` supports XFA forms. These forms are organizing their fields in a tree structure. This tree structure shows in the field names reported by `(formData)`. The field names are inspired by the field names the Java library iText uses, but without the array indexes.\r\n\r\nIn contrast, `[formData]` optionally allows you to use the unqualified field name (i.e. only the last part of the name). Of course, two-way binding converts this field name to a fully qualified name in `(formData)`. \r\n\r\n**Note**: If the field name matches several fields, the PDF viewer populates a random field. Or even all of them simultaneously. Do yourself a favor and avoid the ambiguity.\r\n\r\nUnfortunately I cannot set up a demo, because until now, I've failed to find or create a demo file with a liberal license. I apologize for the inconvenience."
  },
  {
    "title": "Zoom",
    "route": "/viewing/zoom/",
    "content": "The attribute `[(zoom)]` controls the zoom level of the PDF document. If you're using two-way binding, the variable is updated\r\nwhen the user zooms in or out.\r\n\r\n## Huge Zoom Levels\r\n\r\nIf the resolution of the PDF is very high, the PDF viewer calculates the maximum canvas size. If the canvas size exceeds the maximum canvas size, `ngx-extended-pdf-viewer` reduces the resolution and activates CSS scaling. On most devices and with most PDF documents, this probably never happens.\r\n\r\nYou can trade performance for blurriness by limiting the maximum canvas size by setting `pdfDefaultOptions.maxCanvasPixels` in the constructor.\r\n\r\nHere's a [list of the maximum canvas sizes](https://www.npmjs.com/package/canvas-size#test-results) on many browsers and devices.\r\n\r\nIf you exceed this setting, or if the necessary canvas size is larger than `pdfDefaultOptions.maxCanvasPixels` defines, `ngx-extended-pdf-viewer` limits the canvas size and activates CSS scaling. So you can get higher zoom levels, but the text may be blurry.\r\n\r\n## HTML\r\n\r\n```html\r\n<ngx-extended-pdf-viewer\r\n  [src]=\"'/assets/pdfs/BootsFaces_Deep_Dive_1.0.pdf'\"\r\n  (currentZoomFactor)=\"updateZoomFactor($event)\"\r\n  [height]=\"'90vh'\"\r\n  [(zoom)]=\"zoomSetting\"\r\n  [minZoom]=\"minZoom\" [maxZoom]=\"maxZoom\"\r\n  [zoomLevels]=\"zoomLevels\"\r\n  >\r\n</ngx-extended-pdf-viewer>\r\n```\r\n\r\n## TypeScript\r\n\r\n```typescript\r\n@Component({\r\nstandalone: false,  ... })\r\nexport class ZoomComponent {\r\n  public isMobile = 'ontouchstart' in document.documentElement;\r\n  public minZoom = 0.33;\r\n  public maxZoom = 3;\r\n  public zoomLevels = ['auto', 'page-actual', 'page-fit', 'page-width', 0.2, 0.25, 0.33, 0.5, 0.75, 1, 1.25, 1.5, 2, 2.5, 3, 3.5, 4];\r\n  private _zoomSetting: number | string | undefined = 'page-width';\r\n  private currentZoomFactor: number;\r\n\r\n  public get zoomSetting() {\r\n    return String(this._zoomSetting);\r\n  }\r\n  public set zoomSetting(zoom: string) {\r\n    if (isNaN(Number(zoom))) {\r\n      this._zoomSetting = zoom;\r\n    } else {\r\n      this._zoomSetting = zoom + '%';\r\n    }\r\n  }\r\n  public updateZoomFactor(zoom: number): void {\r\n    this.currentZoomFactor = zoom;\r\n  }\r\n}\r\n```"
  }
]